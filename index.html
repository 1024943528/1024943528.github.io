<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/22/vue3/" class="article-date">
  <time datetime="2021-08-22T07:09:41.771Z" itemprop="datePublished">2021-08-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">title: vue</span><br><span class="line">date: 2021-2-9 13:47:17</span><br><span class="line">tags:</span><br></pre></td></tr></table></figure>

<h2 id="1-组合式api"><a href="#1-组合式api" class="headerlink" title="1.组合式api"></a>1.组合式api</h2><h2 id="2-setup"><a href="#2-setup" class="headerlink" title="2.setup"></a>2.setup</h2><blockquote>
<p>在 <code>setup</code> 中你应该避免使用 <code>this</code>，因为它不会找到组件实例。<code>setup</code> 的调用发生在 <code>data</code> property、<code>computed</code> property 或 <code>methods</code> 被解析之前，所以它们无法在 <code>setup</code> 中被获取。</p>
</blockquote>
<h2 id="3-带-ref-的响应式变量"><a href="#3-带-ref-的响应式变量" class="headerlink" title="3.带 ref 的响应式变量"></a>3.带 <code>ref</code> 的响应式变量</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/22/vue3/" data-id="ckub19isb000ddxgrhzai39ai" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-HTML5新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/03/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/" class="article-date">
  <time datetime="2021-08-03T10:58:12.676Z" itemprop="datePublished">2021-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/03/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/" data-id="ckub19ir50000dxgr6ers15g6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-webscoket" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/08/03/webscoket/" class="article-date">
  <time datetime="2021-08-03T06:53:34.346Z" itemprop="datePublished">2021-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>为什么需要webscoket?</p>
<ul>
<li>解决了http只能单向通信的痛点，可以服务端可以主动告诉服务端发生了什么</li>
<li>也可以客户端通知服务端</li>
</ul>
</li>
<li><p>webscoket如何使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WebSocket 对象作为一个构造函数，用于新建 WebSocket 实例</span></span><br><span class="line"><span class="comment">//执行下面语句之后，客户端就会与服务器进行连接。</span></span><br><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">&quot;wss://echo.websocket.org&quot;</span>);</span><br><span class="line"></span><br><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection open ...&quot;</span>); </span><br><span class="line">  ws.send(<span class="string">&quot;Hello WebSockets!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">&quot;Received Message: &quot;</span> + evt.data);</span><br><span class="line">  ws.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ws.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Connection closed.&quot;</span>);</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>
</li>
<li><p>Webscoket 有哪些API</p>
<ul>
<li><p>Webscoket 构造函数</p>
</li>
<li><p>Webscoket.readstate(<code>readyState</code>属性返回实例对象的当前状态，共有四种)</p>
<blockquote>
<p>CONNECTING：值为0，表示正在连接。</p>
<p>OPEN：值为1，表示连接成功，可以通信了。</p>
<p>CLOSING：值为2，表示连接正在关闭。</p>
<p>CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</p>
</blockquote>
</li>
<li><p>Webscoket.onopen</p>
<ul>
<li>用于指定连接成功后的回调函数。</li>
</ul>
</li>
<li><p>Webscoket.onclose</p>
<ul>
<li>用于指定连接关闭后的回调函数。</li>
</ul>
</li>
<li><p>Webscoket.onmessage</p>
<ul>
<li>用于指定收到服务器数据后的回调函数。</li>
</ul>
</li>
<li><p>Webscoket.send</p>
<ul>
<li>方法用于向服务器发送数据。</li>
</ul>
</li>
<li><p>Webscoket.bufferedamount</p>
<ul>
<li>表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束</li>
</ul>
</li>
<li><p>Webscoket.onerror</p>
<ul>
<li>用于指定报错时的回调函数。</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/03/webscoket/" data-id="ckub19isf000idxgr89ok9nl7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-axios" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/07/29/axios/" class="article-date">
  <time datetime="2021-07-29T06:41:25.985Z" itemprop="datePublished">2021-07-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/29/axios/" data-id="ckub19irh0001dxgr9b0554j1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue-Router" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/01/Vue-Router/" class="article-date">
  <time datetime="2021-03-01T12:47:17.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/01/Vue-Router/">vue-router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/Vue-Router/" data-id="ckub19is9000cdxgr6walcgf6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Git和Svn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/01/Git%E5%92%8CSvn/" class="article-date">
  <time datetime="2021-03-01T05:47:17.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/01/Git%E5%92%8CSvn/">Git 和 Svn</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="git和svn区别"><a href="#git和svn区别" class="headerlink" title="git和svn区别"></a>git和svn区别</h3><ul>
<li>1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</li>
<li>2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</li>
<li>3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。</li>
<li>4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</li>
<li>5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li>
</ul>
<h3 id="git基本命令"><a href="#git基本命令" class="headerlink" title="git基本命令"></a>git基本命令</h3><ul>
<li><p>git init 创建新的git仓库</p>
</li>
<li><p>检出仓库</p>
<ul>
<li>git clone /path/to/repository（执行如下命令以创建一个本地仓库的克隆版本：）</li>
<li>git clone username@host:/path/to/repository</li>
</ul>
</li>
<li><p>工作流</p>
<ul>
<li>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 工作目录，它持有实际文件；第二个是 暂存区（Index），它像个缓存区域，临时保存你的改动；最后是 HEAD，它指向你最后一次提交的结果。</li>
</ul>
</li>
<li><p>添加和提交</p>
<ul>
<li>git add<filename> git add *</li>
<li>git commit -m “代码提交信息”(你的改动已经提交到了 HEAD，但是还没到你的远端仓库。)</li>
</ul>
</li>
<li><p>推送和改动</p>
<ul>
<li>git push origin master</li>
<li>git remote add origin <server> 将你的改动推送到所添加的服务器上去了。</li>
</ul>
</li>
</ul>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul>
<li>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</li>
<li>git checkout -b feature_x （创建一个叫做“feature_x”的分支，并切换过去：）</li>
<li>git checkout master （切换回主分支）</li>
<li>git branch -d feature_x （再把新建的分支删掉：）</li>
</ul>
<h3 id="更新与合并"><a href="#更新与合并" class="headerlink" title="更新与合并"></a>更新与合并</h3><ul>
<li>git pull 要更新你的本地仓库至最新改动，执行</li>
<li>git merge <branch> 合并其他分支到你的当前分支（例如 master），执行</li>
<li>git add <filename> 手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功：</li>
<li>git diff <source_branch> <target_branch> 在合并改动之前，你可以使用如下命令预览差异</li>
</ul>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><ul>
<li>git tag 1.0.0 1b2e1d63ff （1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。可以使用下列命令</li>
<li>git log 获取提交 ID： 你也可以使用少一点的提交 ID 前几位，只要它的指向具有唯一性。）</li>
</ul>
<h3 id="替换本地改动"><a href="#替换本地改动" class="headerlink" title="替换本地改动"></a>替换本地改动</h3><ul>
<li>git checkout – <filename> 假如你操作失误（当然，这最好永远不要发生），你可以使用如下命令替换掉本地改动</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/Git%E5%92%8CSvn/" data-id="ckub19irw0002dxgrdot86h0l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vuex" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/01/Vuex/" class="article-date">
  <time datetime="2021-03-01T05:47:17.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/01/Vuex/">vuex</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/Vuex/" data-id="ckub19is6000adxgr3f0gfix5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Sass" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/19/Sass/" class="article-date">
  <time datetime="2021-02-18T16:00:00.000Z" itemprop="datePublished">2021-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/19/Sass/">Sass使用指南</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="使用sass"><a href="#使用sass" class="headerlink" title="使用sass"></a>使用sass</h3><ul>
<li><p>嵌套规则</p>
</li>
<li><p>父选择器 &amp;</p>
<ul>
<li>在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 &amp; 代表嵌套规则外层的父选择器。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>: underline; &#125;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-class">.firefox</span> &amp; &#123; <span class="attribute">font-weight</span>: normal; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--编译为--&gt;</span><br><span class="line"> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none; &#125;</span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">text-decoration</span>: underline; &#125;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-class">.firefox</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: normal; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性嵌套</p>
<ul>
<li>有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中，</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="selector-class">.funky</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: &#123;</span><br><span class="line">    family: fantasy;</span><br><span class="line">    size: <span class="number">30em</span>;</span><br><span class="line">    weight: bold;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;!--编译为--&gt;</span><br><span class="line"><span class="selector-class">.funky</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: fantasy;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>占位符选择器 %foo</p>
<ul>
<li>Sass 额外提供了一种特殊类型的选择器：占位符选择器 (placeholder selector)。与常用的 id 与 class 选择器写法相似，只是 # 或 . 替换成了 %。必须通过 @extend 指令调用，更多介绍请查阅 @extend-Only Selectors。</li>
<li>当占位符选择器单独使用时（未通过 @extend 调用），不会编译到 CSS 文件中</li>
</ul>
</li>
<li><p>注释/**/ 和//</p>
<ul>
<li>Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/19/Sass/" data-id="ckub19is30007dxgr1ewfhd9l" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/09/Vue/" class="article-date">
  <time datetime="2021-02-09T05:47:17.000Z" itemprop="datePublished">2021-02-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/09/Vue/">vue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="vue-与模版"><a href="#vue-与模版" class="headerlink" title="vue 与模版"></a>vue 与模版</h3><p>1.编写页面和模版</p>
<ul>
<li>  直接在 html 中写标签</li>
<li>  使用 template</li>
<li>  使用单文件 <template></li>
<li><ol start="2">
<li>创建 vue 实例</li>
</ol>
</li>
<li>  在 vue 的构造函数中提供：data,method,computed,watcher,props….</li>
<li><ol start="3">
<li>将 vue 挂载到页面中（mount ）</li>
</ol>
</li>
</ul>
<h3 id="createElement-参数"><a href="#createElement-参数" class="headerlink" title="createElement 参数"></a>createElement 参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">createElement(<span class="string">&quot;div&quot;</span>, &#123;&#125;, [</span><br><span class="line">    <span class="string">&quot;先写一些文字&quot;</span>,</span><br><span class="line">    createElement(<span class="string">&quot;h1&quot;</span>, <span class="string">&quot;一则头条&quot;</span>),</span><br><span class="line">    createElement(MyComponent, &#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">            someProp: <span class="string">&quot;foobar&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>

<h3 id="深入数据对象"><a href="#深入数据对象" class="headerlink" title="深入数据对象"></a>深入数据对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&#x27;class&#x27;</span>: &#123;</span><br><span class="line">    foo: <span class="literal">true</span>,</span><br><span class="line">    bar: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  style: &#123;</span><br><span class="line">    color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;14px&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  attrs: &#123;</span><br><span class="line">    id: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    myProp: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  domProps: &#123;</span><br><span class="line">    innerHTML: <span class="string">&#x27;baz&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  on: &#123;</span><br><span class="line">    click: <span class="built_in">this</span>.clickHandler</span><br><span class="line">  &#125;,</span><br><span class="line">  nativeOn: &#123;</span><br><span class="line">    click: <span class="built_in">this</span>.nativeClickHandler</span><br><span class="line">  &#125;,</span><br><span class="line">  directives: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: <span class="string">&#x27;my-custom-directive&#x27;</span>,</span><br><span class="line">      value: <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">      expression: <span class="string">&#x27;1 + 1&#x27;</span>,</span><br><span class="line">      arg: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">      modifiers: &#123;</span><br><span class="line">        bar: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> createElement(<span class="string">&#x27;span&#x27;</span>, props.text)</span><br><span class="line">  &#125;,</span><br><span class="line">  slot: <span class="string">&#x27;name-of-slot&#x27;</span>,</span><br><span class="line">  key: <span class="string">&#x27;myKey&#x27;</span>,</span><br><span class="line">  ref: <span class="string">&#x27;myRef&#x27;</span>,</span><br><span class="line">   refInFor: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><p>Node 必须唯一<br>组件树中的所有 VNode 必须是唯一的。这意味着，下面的渲染函数是不合法的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myParagraphVNode = createElement(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    <span class="comment">// 错误 - 重复的 VNode</span></span><br><span class="line">    myParagraphVNode, myParagraphVNode</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  工厂函数：指这些内建函数都是类对象，当你调用他们时，实际上是创建了一个类实例意思就是当我调用这个函数，实际上是先利用类创建了一个对象，然后返回这个对象。由于 Javascript 本身不是严格的面向对象的语言（不包含类），实际上来说，Javascript 并没有严格的“工厂函数”，但是在 Javascript 中，我们能利用函数模拟类。</li>
<li>  如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这渲染函数用完全合法的方式渲染了 20 个相同的段落：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123; <span class="attr">length</span>: <span class="number">20</span> &#125;).map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li>  渲染函数中没有与 v-model 的直接对应——你必须自己实现相应的逻辑</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;value&#x27;</span>],</span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">    domProps: &#123;</span><br><span class="line">      value: self.value</span><br><span class="line">    &#125;,</span><br><span class="line">    on: &#123;</span><br><span class="line">      input: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        self.$emit(<span class="string">&#x27;input&#x27;</span>, event.target.value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="事件-amp-案件修饰符"><a href="#事件-amp-案件修饰符" class="headerlink" title="事件&amp;案件修饰符"></a>事件&amp;案件修饰符</h3><p>对于 .passive、.capture 和 .once 这些事件修饰符，Vue 提供了相应的前缀可以用于 on：</p>
<ul>
<li>  stop：等同于 JavaScript 中的 event.stopPropagation()，防止事件冒泡</li>
<li>  prevent：等同于 JavaScript 中的 event.preventDefault()，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）</li>
<li>  capture：与事件冒泡的方向相反，事件捕获由外到内</li>
<li>  self：只会触发自己范围内的事件，不包含子元素</li>
<li>  once：只会触发一次</li>
</ul>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><ul>
<li>  你可以通过 this.$slots 访问静态插槽的内容，每个插槽都是一个 VNode 数组</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.$slots.default)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  也可以通过 this.$scopedSlots 访问作用域插槽，每个作用域插槽都是一个返回若干 VNode 的函数：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&#x27;message&#x27;</span>],</span><br><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// `&lt;div&gt;&lt;slot :text=&quot;message&quot;&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">  <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>, [</span><br><span class="line">    <span class="built_in">this</span>.$scopedSlots.default(&#123;</span><br><span class="line">      text: <span class="built_in">this</span>.message</span><br><span class="line">    &#125;)</span><br><span class="line">  ])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="如何理解-vue-中的-this-指向问题"><a href="#如何理解-vue-中的-this-指向问题" class="headerlink" title="如何理解 vue 中的 this 指向问题"></a>如何理解 vue 中的 this 指向问题</h3><ul>
<li><p>1.js 执行上下文</p>
<ul>
<li>  全局执行上下文（全局执行上下文只有一个，在客户端中一般由浏览器创建，也就是我们熟知的 window 对象，我们能通过 this 直接访问到它）（全局对象 window 上预定义了大量的方法和属性，我们在全局环境的任意处都能直接访问这些属性方法，同时 window 对象还是 var 声明的全局变量的载体。我们通过 var 创建的全局对象，都可以通过 window 直接访问。）</li>
<li>  函数上下文（函数执行上下文可存在无数个，每当一个函数被调用时都会创建一个函数上下文；）</li>
<li>  eval 上下文</li>
</ul>
</li>
<li><p>2.执行上下文栈(执行栈)</p>
<ul>
<li>  执行上下文栈(下文简称执行栈)也叫调用栈，执行栈用于存储代码执行期间创建的所有上下文，具有 LIFO（Last In First Out 后进先出，也就是先进后出）的特性。</li>
</ul>
</li>
<li><p>  3.执行上下文创建</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutionContext = &#123;</span><br><span class="line">    <span class="comment">// 确定this的值</span></span><br><span class="line">    ThisBinding = <span class="xml"><span class="tag">&lt;<span class="name">this</span> <span class="attr">value</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    // 创建词法环境组件</span></span><br><span class="line"><span class="xml">    LexicalEnvironment = &#123;&#125;,</span></span><br><span class="line"><span class="xml">    // 创建变量环境组件</span></span><br><span class="line"><span class="xml">    VariableEnvironment = &#123;&#125;,</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  1.ThisBinding</li>
<li>2.词法环境组件<ul>
<li>全局词法环境组件<ul>
<li>  对外部环境的引入记录为 null，因为它本身就是最外层环境，除此之外它还记录了当前环境下的所有属性、方法位置。</li>
</ul>
</li>
<li>函数词法环境组件<ul>
<li>  包含了用户在函数中定义的所有属性方法外，还包含了一个 arguments 对象。函数词法环境的外部环境引入可以是全局环境，也可以是其它函数环境</li>
</ul>
</li>
</ul>
</li>
<li>3.变量环境组件<ul>
<li>  变量环境可以说也是词法环境，它具备词法环境所有属性，一样有环境记录与外部环境引入。在 ES6 中唯一的区别在于词法环境用于存储函数声明与 let const 声明的变量，而变量环境仅仅存储 var 声明的变量。</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局环境</span></span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    <span class="comment">// 全局词法环境</span></span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        <span class="comment">// 环境记录</span></span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: <span class="string">&quot;Object&quot;</span>, <span class="comment">//类型为对象环境记录</span></span><br><span class="line">            <span class="comment">// 标识符绑定在这里</span></span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt; <span class="literal">null</span> &gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数环境</span></span><br><span class="line">FunctionExectionContext = &#123;</span><br><span class="line">    <span class="comment">// 函数词法环境</span></span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">        <span class="comment">// 环境纪录</span></span><br><span class="line">        EnvironmentRecord: &#123;</span><br><span class="line">            Type: <span class="string">&quot;Declarative&quot;</span>, <span class="comment">//类型为声明性环境记录</span></span><br><span class="line">            <span class="comment">// 标识符绑定在这里</span></span><br><span class="line">        &#125;,</span><br><span class="line">        outer: &lt; Global or outerfunction environment reference &gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局执行上下文</span></span><br><span class="line">GlobalExectionContext = &#123;</span><br><span class="line">    <span class="comment">// this绑定为全局对象</span></span><br><span class="line">    ThisBinding: <span class="xml"><span class="tag">&lt;<span class="name">Global</span> <span class="attr">Object</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">    // 词法环境</span></span><br><span class="line"><span class="xml">    LexicalEnvironment: &#123;</span></span><br><span class="line"><span class="xml">        //环境记录</span></span><br><span class="line"><span class="xml">      EnvironmentRecord: &#123;</span></span><br><span class="line"><span class="xml">        Type: &quot;Object&quot;,  // 对象环境记录</span></span><br><span class="line"><span class="xml">        // 标识符绑定在这里 let const创建的变量a b在这</span></span><br><span class="line"><span class="xml">        a: &lt; uninitialized &gt;,</span></span><br><span class="line"><span class="xml">        b: &lt; uninitialized &gt;,</span></span><br><span class="line"><span class="xml">        multiply: &lt; func &gt;</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">      // 全局环境外部环境引入为null</span></span><br><span class="line">      outer: &lt;null&gt;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">      EnvironmentRecord: &#123;</span><br><span class="line">        Type: &quot;Object&quot;,  // 对象环境记录</span><br><span class="line">        // 标识符绑定在这里  var创建的c在这</span><br><span class="line">        c: undefined,</span><br><span class="line">      &#125;</span><br><span class="line">      // 全局环境外部环境引入为null</span><br><span class="line">      outer: &lt;null&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 函数执行上下文</span><br><span class="line">  FunctionExectionContext = &#123;</span><br><span class="line">     //由于函数是默认调用 this绑定同样是全局对象</span><br><span class="line">    ThisBinding: &lt;Global Object&gt;,</span><br><span class="line">    // 词法环境</span><br><span class="line">    LexicalEnvironment: &#123;</span><br><span class="line">      EnvironmentRecord: &#123;</span><br><span class="line">        Type: &quot;Declarative&quot;,  // 声明性环境记录</span><br><span class="line">        // 标识符绑定在这里  arguments对象在这</span><br><span class="line">        Arguments: &#123;0: 20, 1: 30, length: 2&#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      // 外部环境引入记录为&lt;/Global&gt;</span><br><span class="line">      outer: &lt;GlobalEnvironment&gt;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    VariableEnvironment: &#123;</span><br><span class="line">      EnvironmentRecord: &#123;</span><br><span class="line">        Type: &quot;Declarative&quot;,  // 声明性环境记录</span><br><span class="line">        // 标识符绑定在这里  var创建的g在这</span><br><span class="line">        g: undefined</span><br><span class="line">      &#125;,</span><br><span class="line">      // 外部环境引入记录为&lt;/Global&gt;</span><br><span class="line">      outer: &lt;GlobalEnvironment&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



<h2 id="vue3新增内容"><a href="#vue3新增内容" class="headerlink" title="vue3新增内容"></a>vue3新增内容</h2><h2 id="1-setup"><a href="#1-setup" class="headerlink" title="1) setup"></a>1) setup</h2><ul>
<li>新的option, 所有的组合API函数都在此使用, 只在初始化时执行一次</li>
<li>函数如果返回对象, 对象中的属性或方法, 模板中可以直接使用</li>
</ul>
<h2 id="2-ref"><a href="#2-ref" class="headerlink" title="2) ref"></a>2) ref</h2><ul>
<li>作用: 定义一个数据的响应式</li>
<li>语法: const xxx = ref(initValue):<ul>
<li>创建一个包含响应式数据的引用(reference)对象</li>
<li>js中操作数据: xxx.value</li>
<li>模板中操作数据: 不需要.value</li>
</ul>
</li>
</ul>
<h2 id="3-reactive"><a href="#3-reactive" class="headerlink" title="3) reactive"></a>3) reactive</h2><ul>
<li>作用: 定义多个数据的响应式</li>
<li>const proxy = reactive(obj): 接收一个普通对象然后返回该普通对象的响应式代理器对象</li>
<li>响应式转换是“深层的”：会影响对象内部所有嵌套的属性</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据都是响应式的</li>
</ul>
<h2 id="4-比较Vue2与Vue3的响应式-重要"><a href="#4-比较Vue2与Vue3的响应式-重要" class="headerlink" title="4) 比较Vue2与Vue3的响应式(重要)"></a>4) 比较Vue2与Vue3的响应式(重要)</h2><h2 id="vue2的响应式"><a href="#vue2的响应式" class="headerlink" title="vue2的响应式"></a>vue2的响应式</h2><ul>
<li><p>核心:</p>
<ul>
<li>对象: 通过defineProperty对对象的已有属性值的读取和修改进行劫持(监视/拦截)</li>
<li>数组: 通过重写数组更新数组一系列更新元素的方法来实现元素修改的劫持</li>
</ul>
</li>
<li><p>问题</p>
<ul>
<li>对象直接新添加的属性或删除已有属性, 界面不会自动更新</li>
<li>直接通过下标替换元素或更新length, 界面不会自动更新 arr[1] = {}</li>
</ul>
</li>
</ul>
<h2 id="Vue3的响应式"><a href="#Vue3的响应式" class="headerlink" title="Vue3的响应式"></a>Vue3的响应式</h2><ul>
<li>核心:<ul>
<li>通过Proxy(代理): 拦截对data任意属性的任意(13种)操作, 包括属性值的读写, 属性的添加, 属性的删除等…</li>
<li>通过 Reflect(反射): 动态对被代理对象的相应属性进行特定的操作</li>
</ul>
</li>
</ul>
<h2 id="5-setup细节"><a href="#5-setup细节" class="headerlink" title="5) setup细节"></a>5) setup细节</h2><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行(一次), 此时组件对象还没有创建</li>
<li>this是undefined, 不能通过this来访问data/computed/methods / props</li>
<li>其实所有的composition API相关回调函数中也都不可以</li>
</ul>
</li>
<li><p>setup的返回值</p>
<ul>
<li>一般都返回一个对象: 为模板提供数据, 也就是模板中可以直接使用此对象中的所有属性/方法</li>
<li>返回对象中的属性会与data函数返回对象的属性合并成为组件对象的属性</li>
<li>返回对象中的方法会与methods中的方法合并成功组件对象的方法</li>
<li>如果有重名, setup优先</li>
</ul>
</li>
<li><p>注意:</p>
<ul>
<li>一般不要混合使用: methods中可以访问setup提供的属性和方法, 但在setup方法中不能访问data和methods</li>
<li>setup不能是一个async函数: 因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性数据</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>setup(props, context) / setup(props, {attrs, slots, emit})</li>
<li>props: 包含props配置声明且传入了的所有属性的对象</li>
<li>attrs: 包含没有在props配置中声明的属性的对象, 相当于 this.$attrs</li>
<li>slots: 包含所有传入的插槽内容的对象, 相当于 this.$slots</li>
<li>emit: 用来分发自定义事件的函数, 相当于 this.$emit</li>
</ul>
</li>
</ul>
<h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7) 计算属性与监视"></a>7) 计算属性与监视</h2><ul>
<li>computed函数:<ul>
<li>与computed配置功能一致</li>
<li>只有getter</li>
<li>有getter和setter</li>
</ul>
</li>
<li>watch函数<ul>
<li>与watch配置功能一致</li>
<li>监视指定的一个或多个响应式数据, 一旦数据变化, 就自动执行监视回调</li>
<li>默认初始时不执行回调, 但可以通过配置immediate为true, 来指定初始时立即执行第一次</li>
<li>通过配置deep为true, 来指定深度监视</li>
</ul>
</li>
<li>watchEffect函数<ul>
<li>不用直接指定要监视的数据, 回调函数中使用的哪些响应式数据就监视哪些响应式数据</li>
<li>默认初始时就会执行第一次, 从而可以收集需要监视的数据</li>
<li>监视数据发生变化时回调</li>
</ul>
</li>
</ul>
<h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8) 生命周期"></a>8) 生命周期</h2><ul>
<li><p><code>beforeCreate</code> -&gt; 使用 <code>setup()</code></p>
</li>
<li><p><code>created</code> -&gt; 使用 <code>setup()</code></p>
</li>
<li><p><code>beforeMount</code> -&gt; <code>onBeforeMount</code></p>
</li>
<li><p><code>mounted</code> -&gt; <code>onMounted</code></p>
</li>
<li><p><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></p>
</li>
<li><p><code>updated</code> -&gt; <code>onUpdated</code></p>
</li>
<li><p><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></p>
</li>
<li><p><code>destroyed</code> -&gt; <code>onUnmounted</code></p>
</li>
<li><p><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></p>
</li>
<li><p>onRenderTracked</p>
</li>
<li><p>onRenderTriggered</p>
</li>
</ul>
<h2 id="09-自定义hook函数"><a href="#09-自定义hook函数" class="headerlink" title="09) 自定义hook函数"></a>09) 自定义hook函数</h2><ul>
<li><p>使用Vue3的组合API封装的可复用的功能函数</p>
</li>
<li><p>自定义hook的作用类似于vue2中的mixin技术</p>
</li>
<li><p>自定义Hook的优势: 很清楚复用功能代码的来源, 更清楚易懂</p>
</li>
</ul>
<h2 id="10-toRefs"><a href="#10-toRefs" class="headerlink" title="10) toRefs"></a>10) toRefs</h2><h4 id="toRef接收单个属性，为所有属性创建ref对象"><a href="#toRef接收单个属性，为所有属性创建ref对象" class="headerlink" title="toRef接收单个属性，为所有属性创建ref对象"></a>toRef接收单个属性，为所有属性创建ref对象</h4><p>把一个响应式对象转换成普通对象，该普通对象的每个 property 都是一个 ref</p>
<p>应用: 当从合成函数返回响应式对象时，toRefs 非常有用，这样消费组件就可以在不丢失响应式的情况下对返回的对象进行分解使用</p>
<h2 id="11-ref获取元素"><a href="#11-ref获取元素" class="headerlink" title="11) ref获取元素"></a>11) ref获取元素</h2><p>利用ref函数获取组件中的标签元素</p>
<p>功能需求: 让输入框自动获取焦点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;h2&gt;App&lt;/h2&gt;</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span>&gt;---</span><br><span class="line">  &lt;input type=<span class="string">&quot;text&quot;</span> ref=<span class="string">&quot;inputRef&quot;</span>&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; onMounted, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">ref获取元素: 利用ref函数获取组件中的标签元素</span></span><br><span class="line"><span class="comment">功能需求: 让输入框自动获取焦点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = ref&lt;HTMLElement|<span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">    onMounted(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      inputRef.value &amp;&amp; inputRef.value.focus()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      inputRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>





<h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1) shallowReactive 与 shallowRef"></a>1) shallowReactive 与 shallowRef</h2><ul>
<li><p>shallowReactive : 只处理了对象内最外层属性的响应式(也就是浅响应式)</p>
</li>
<li><p>shallowRef: 只处理了value的响应式, 不进行对象的reactive处理</p>
</li>
<li><p>什么时候用浅响应式呢?</p>
<ul>
<li>一般情况下使用ref和reactive即可</li>
<li>如果有一个对象数据, 结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive</li>
<li>如果有一个对象数据, 后面会产生新的对象来替换 ===&gt; shallowRef</li>
</ul>
</li>
</ul>
<h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2) readonly 与 shallowReadonly"></a>2) readonly 与 shallowReadonly</h2><ul>
<li>readonly:<ul>
<li>深度只读数据</li>
<li>获取一个对象 (响应式或纯对象) 或 ref 并返回原始代理的只读代理。</li>
<li>只读代理是深层的：访问的任何嵌套 property 也是只读的。</li>
</ul>
</li>
<li>shallowReadonly<ul>
<li>浅只读数据</li>
<li>创建一个代理，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换</li>
</ul>
</li>
<li>应用场景:<ul>
<li>在某些特定情况下, 我们可能不希望对数据进行更新的操作, 那就可以包装生成一个只读代理对象来读取数据, 而不能修改或删除</li>
</ul>
</li>
</ul>
<h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3) toRaw 与 markRaw"></a>3) toRaw 与 markRaw</h2><ul>
<li>toRaw  (将reactive或readonlyb变回普通对象)<ul>
<li>返回由 <code>reactive</code> 或 <code>readonly</code> 方法转换成响应式代理的普通对象。</li>
<li>这是一个还原方法，可用于临时读取，访问不会被代理/跟踪，写入时也不会触发界面更新。</li>
</ul>
</li>
<li>markRaw<ul>
<li>标记一个对象，使其永远不会转换为代理。返回对象本身</li>
<li>应用场景:<ul>
<li>有些值不应被设置为响应式的，例如复杂的第三方类实例或 Vue 组件对象。</li>
<li>当渲染具有不可变数据源的大列表时，跳过代理转换可以提高性能。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-toRef"><a href="#4-toRef" class="headerlink" title="4) toRef"></a>4) toRef</h2><ul>
<li>为源响应式对象上的某个属性创建一个 ref对象, 二者内部操作的是同一个数据值, 更新时二者是同步的</li>
<li>和ref的区别: ref是拷贝了一份新的数据值单独操作, 更新时相互不影响</li>
<li>应用: 当要将 某个prop 的 ref 传递给复合函数时，toRef 很有用</li>
</ul>
<h2 id="5-customRef"><a href="#5-customRef" class="headerlink" title="5) customRef"></a>5) customRef</h2><ul>
<li>创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制</li>
<li>需求: 使用 customRef 实现 debounce 的示例</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function useDebouncedRef&lt;T&gt;(value: T, delay &#x3D; 200) &#123;</span><br><span class="line">  let timeout: number</span><br><span class="line">  return customRef((track, trigger) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        &#x2F;&#x2F; 告诉Vue追踪数据</span><br><span class="line">        track()</span><br><span class="line">        return value</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newValue: T) &#123;</span><br><span class="line">        clearTimeout(timeout)</span><br><span class="line">        timeout &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">          value &#x3D; newValue</span><br><span class="line">          &#x2F;&#x2F; 告诉Vue去触发界面更新</span><br><span class="line">          trigger()</span><br><span class="line">        &#125;, delay)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-provide-与-inject"><a href="#6-provide-与-inject" class="headerlink" title="6) provide 与 inject"></a>6) provide 与 inject</h2><ul>
<li>provide<code>和</code>inject<code>提供依赖注入，功能类似 2.x 的</code>provide/inject</li>
<li>实现跨层级组件(祖孙)间通信</li>
</ul>
<h2 id="7-响应式数据的判断"><a href="#7-响应式数据的判断" class="headerlink" title="7) 响应式数据的判断"></a>7) 响应式数据的判断</h2><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h1 id="1-新组件"><a href="#1-新组件" class="headerlink" title="1. 新组件"></a>1. 新组件</h1><h2 id="1-Fragment-片断"><a href="#1-Fragment-片断" class="headerlink" title="1) Fragment(片断)"></a>1) Fragment(片断)</h2><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中(不再需要div元素)</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h2&gt;aaaa&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;h2&gt;aaaa&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure>



<h2 id="2-Teleport-瞬移"><a href="#2-Teleport-瞬移" class="headerlink" title="2) Teleport(瞬移)"></a>2) Teleport(瞬移)</h2><ul>
<li>Teleport 提供了一种干净的方法, 让组件的html在父组件界面外的特定标签(很可能是body)下插入显示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button @click&#x3D;&quot;modalOpen &#x3D; true&quot;&gt;</span><br><span class="line">      Open full screen modal! (With teleport!)</span><br><span class="line">  &lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;teleport to&#x3D;&quot;body&quot;&gt;</span><br><span class="line">    &lt;div v-if&#x3D;&quot;modalOpen&quot; class&#x3D;&quot;modal&quot;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        I&#39;m a teleported modal! </span><br><span class="line">        (My parent is &quot;body&quot;)</span><br><span class="line">        &lt;button @click&#x3D;&quot;modalOpen &#x3D; false&quot;&gt;</span><br><span class="line">          Close</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;teleport&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &#39;vue&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;modal-button&#39;,</span><br><span class="line">  setup () &#123;</span><br><span class="line">    const modalOpen &#x3D; ref(false)</span><br><span class="line">    return &#123;</span><br><span class="line">      modalOpen</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-Suspense-不确定的"><a href="#3-Suspense-不确定的" class="headerlink" title="3) Suspense(不确定的)"></a>3) Suspense(不确定的)</h2><ul>
<li>它们允许我们的应用程序在等待异步组件时渲染一些后备内容，可以让我们创建一个平滑的用户体验</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;Suspense&gt;</span><br><span class="line">    &lt;template v-slot:default&gt;</span><br><span class="line">      &lt;AsyncComp&#x2F;&gt;</span><br><span class="line">      &lt;!-- &lt;AsyncAddress&#x2F;&gt; --&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;template v-slot:fallback&gt;</span><br><span class="line">      &lt;h1&gt;LOADING...&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;template&gt;</span><br><span class="line">  &lt;&#x2F;Suspense&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot;&gt;</span><br><span class="line">&#x2F;* </span><br><span class="line">异步组件 + Suspense组件</span><br><span class="line">*&#x2F;</span><br><span class="line">&#x2F;&#x2F; import AsyncComp from &#39;.&#x2F;AsyncComp.vue&#39;</span><br><span class="line">import AsyncAddress from &#39;.&#x2F;AsyncAddress.vue&#39;</span><br><span class="line">import &#123; defineAsyncComponent &#125; from &#39;vue&#39;</span><br><span class="line">const AsyncComp &#x3D; defineAsyncComponent(() &#x3D;&gt; import(&#39;.&#x2F;AsyncComp.vue&#39;))</span><br><span class="line">export default &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  components: &#123;</span><br><span class="line">    AsyncComp,</span><br><span class="line">    AsyncAddress</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a><code>computed</code></h2><p>接受一个 getter 函数，并为从 getter 返回的值返回一个不变的响应式 <a target="_blank" rel="noopener" href="https://v3.cn.vuejs.org/api/refs-api.html#ref">ref</a> 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const count &#x3D; ref(1)</span><br><span class="line">const plusOne &#x3D; computed(() &#x3D;&gt; count.value + 1)</span><br><span class="line">console.log(plusOne.value) &#x2F;&#x2F; 2</span><br><span class="line">plusOne.value++ &#x2F;&#x2F; 错误</span><br></pre></td></tr></table></figure>

<p>或者，它也可以使用具有 <code>get</code> 和 <code>set</code> 函数的对象来创建可写的 ref 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const count &#x3D; ref(1)</span><br><span class="line">const plusOne &#x3D; computed(&#123;</span><br><span class="line">  get: () &#x3D;&gt; count.value + 1,</span><br><span class="line">  set: val &#x3D;&gt; &#123;</span><br><span class="line">    count.value &#x3D; val - 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">plusOne.value &#x3D; 1 &#x2F;&#x2F;count.value &#x3D; 1 - 1</span><br><span class="line">console.log(count.value) &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>





<h1 id="特殊指令"><a href="#特殊指令" class="headerlink" title="特殊指令"></a>特殊指令</h1><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><blockquote>
<p><code>key</code> 特殊 attribute 主要用做 Vue 的虚拟 DOM 算法的提示，以在比对新旧节点组时辨识 VNodes。如果不使用 key，Vue 会使用一种算法来最小化元素的移动并且尽可能尝试就地修改/复用相同类型元素。而使用 key 时，它会基于 key 的顺序变化重新排列元素，并且 key 不再存在的元素将始终被移除/销毁</p>
</blockquote>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><blockquote>
<p> <code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会被注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是那个 DOM 元素；如果用在子组件上，引用就指向组件实例：</p>
</blockquote>
<h2 id="is"><a href="#is" class="headerlink" title="is"></a>is</h2><blockquote>
<p> 不过，如[解析 DOM 模板时的注意事项]/guide/component-basics.html#解析-dom-模板时的注意事项)里解释的，有的时候你可能需要 Vue 将一个原生元素替换为一个 Vue 组件。这是你可以把 <code>is</code> attribute 的值加上 <code>vue:</code> 前缀，这样 Vue 就会将这些元素换为 Vue 组件进行渲染：</p>
</blockquote>
<h1 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h1><h2 id="watch"><a href="#watch" class="headerlink" title="$watch"></a>$watch</h2><blockquote>
<p>侦听组件实例上的响应式 property 或函数计算结果的变化。回调函数得到的参数为新值和旧值。我们只能将顶层的 <code>data</code>、<code>props</code> 或 <code>computed</code> property 名作为字符串传递。对于更复杂的表达式，用一个函数取代。</p>
</blockquote>
<blockquote>
<p>当侦听的值是一个对象或者数组时，对其属性或元素的任何更改都不会触发侦听器，因为它们引用相同的对象/数组,修改的是对象的属性而不是对象的本身</p>
</blockquote>
<ul>
<li><strong>选项：deep</strong></li>
<li><strong>选项：immediate</strong></li>
<li><strong>选项：flush</strong><ul>
<li>默认值是 <code>&#39;pre&#39;</code>，指定的回调应该在渲染前被调用。它允许回调在模板运行前更新了其他值。</li>
<li><code>&#39;post&#39;</code> 值是可以用来将回调推迟到渲染之后的。如果回调需要通过 <code>$refs</code> 访问更新的 DOM 或子组件，那么则使用该值。</li>
<li>如果 <code>flush</code> 被设置为 <code>&#39;sync&#39;</code>，一旦值发生了变化，回调将被同步调用。</li>
</ul>
</li>
</ul>
<h3 id="副作用刷新时机"><a href="#副作用刷新时机" class="headerlink" title="副作用刷新时机"></a>副作用刷新时机</h3><blockquote>
<p>Vue 的响应性系统会缓存副作用函数，并异步地刷新它们，这样可以避免同一个“tick” 中多个状态改变导致的不必要的重复调用。</p>
<p>在核心的具体实现中，组件的 <code>update</code> 函数也是一个被侦听的副作用。</p>
<p>当一个用户定义的副作用函数进入队列时，默认情况下，会在所有的组件 <code>update</code> <strong>前</strong>执行</p>
</blockquote>
<h3 id="侦听器调试"><a href="#侦听器调试" class="headerlink" title="侦听器调试"></a>侦听器调试</h3><ul>
<li><code>onTrack</code> 和 <code>onTrigger</code> 只能在开发模式下工作<ul>
<li><code>onTrack</code> 将在响应式 property 或 ref 作为依赖项被追踪时被调用。</li>
<li><code>onTrigger</code> 将在依赖项变更导致副作用被触发时被调用。</li>
</ul>
</li>
</ul>
<h3 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 侦听一个 getter</span><br><span class="line">const state &#x3D; reactive(&#123; count: 0 &#125;)</span><br><span class="line">watch(</span><br><span class="line">  () &#x3D;&gt; state.count,</span><br><span class="line">  (count, prevCount) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;* ... *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接侦听ref</span><br><span class="line">const count &#x3D; ref(0)</span><br><span class="line">watch(count, (count, prevCount) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;* ... *&#x2F;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const firstName &#x3D; ref(&#39;&#39;)</span><br><span class="line">const lastName &#x3D; ref(&#39;&#39;)</span><br><span class="line"></span><br><span class="line">watch([firstName, lastName], (newValues, prevValues) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(newValues, prevValues)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">firstName.value &#x3D; &#39;John&#39; &#x2F;&#x2F; logs: [&quot;John&quot;, &quot;&quot;] [&quot;&quot;, &quot;&quot;]</span><br><span class="line">lastName.value &#x3D; &#39;Smith&#39; &#x2F;&#x2F; logs: [&quot;John&quot;, &quot;Smith&quot;] [&quot;John&quot;, &quot;&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="侦听响应式对象"><a href="#侦听响应式对象" class="headerlink" title="侦听响应式对象"></a>侦听响应式对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const numbers &#x3D; reactive([1, 2, 3, 4])</span><br><span class="line"></span><br><span class="line">watch(</span><br><span class="line">  () &#x3D;&gt; [...numbers],</span><br><span class="line">  (numbers, prevNumbers) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(numbers, prevNumbers)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">numbers.push(5) &#x2F;&#x2F; logs: [1,2,3,4,5] [1,2,3,4]</span><br></pre></td></tr></table></figure>
































      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/09/Vue/" data-id="ckub19isq000ldxgrhwyaherd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/16/Java/" class="article-date">
  <time datetime="2021-01-15T16:00:00.000Z" itemprop="datePublished">2021-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/16/Java/">Java从入门到放弃</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="常见的DOS命令"><a href="#常见的DOS命令" class="headerlink" title="常见的DOS命令"></a>常见的DOS命令</h3><blockquote>
<p>dir 列出当前目录下的文件和文件夹<br>md 创建目录<br>rd 删除目录<br>cd 进入指定目录<br>cd.. 返回上一级目录<br>cd/ 返回根目录<br>del 删除文件<br>exit 退出dos命令行</p>
</blockquote>
<ul>
<li>转换从低级到高级。</li>
</ul>
<blockquote>
<p>byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</p>
</blockquote>
<ul>
<li>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</li>
<li>数据类型转换必须满足如下规则：</li>
</ul>
<blockquote>
<ol>
<li>不能对boolean类型进行类型转换。</li>
<li>不能把对象类型转换成不相关类的对象。</li>
<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>
<li>转换过程中可能导致溢出或损失精度.</li>
</ol>
</blockquote>
<h3 id="Java-基本数据类型"><a href="#Java-基本数据类型" class="headerlink" title="Java 基本数据类型"></a>Java 基本数据类型</h3><h3 id="Java-变量类型"><a href="#Java-变量类型" class="headerlink" title="Java 变量类型"></a>Java 变量类型</h3><blockquote>
<p>类变量：独立于方法之外的变量，用 static 修饰。<br>实例变量：独立于方法之外的变量，不过没有 static 修饰。<br>局部变量：类的方法中的变量。</p>
</blockquote>
<h3 id="Java-修饰符"><a href="#Java-修饰符" class="headerlink" title="Java 修饰符"></a>Java 修饰符</h3><ul>
<li>访问控制修饰符</li>
</ul>
<blockquote>
<p>default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。<br>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）<br>public : 对所有类可见。使用对象：类、接口、变量、方法<br>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/16/Java/" data-id="ckub19irz0004dxgrbdzgd34v" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/https-www-tslang-cn-docs-handbook-type-inference-html/" rel="tag">https://www.tslang.cn/docs/handbook/type-inference.html</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/https-www-tslang-cn-docs-handbook-type-inference-html/" style="font-size: 10px;">https://www.tslang.cn/docs/handbook/type-inference.html</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/22/vue3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/03/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/03/webscoket/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/07/29/axios/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/01/Vue-Router/">vue-router</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>