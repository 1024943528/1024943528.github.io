<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Redux" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/02/Redux/" class="article-date">
  <time datetime="2021-01-02T10:17:23.000Z" itemprop="datePublished">2021-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/02/Redux/">Redux</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="基本概念和-API"><a href="#基本概念和-API" class="headerlink" title="基本概念和 API"></a>基本概念和 API</h3><ul>
<li>3.1 Store</li>
</ul>
<blockquote>
<p>Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。Redux 提供createStore这个函数，用来生成 Store。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3.2 State</li>
</ul>
<blockquote>
<p>Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。<br>当前时刻的 State，可以通过store.getState()拿到</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"><span class="keyword">const</span> state = store.getState();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。</p>
</li>
<li><p>3.3 Action</p>
</li>
</ul>
<blockquote>
<p>state 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。<br>可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = &#123;</span><br><span class="line">  type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  payload: <span class="string">&#x27;Learn Redux&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>3.4 Action Creator</li>
</ul>
<blockquote>
<p>View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">&#x27;添加 TODO&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_TODO,</span><br><span class="line">    text</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> action = addTodo(<span class="string">&#x27;Learn Redux&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>3.5 store.dispatch()</p>
</li>
<li><p>store.dispatch()是 View 发出 Action 的唯一方法。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(fn);</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  payload: <span class="string">&#x27;Learn Redux&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>3.6 Reducer</li>
<li>Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state + action.payload;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = reducer(<span class="number">1</span>, &#123;</span><br><span class="line">  type: <span class="string">&#x27;ADD&#x27;</span>,</span><br><span class="line">  payload: <span class="number">2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = [</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;ADD&#x27;</span>, <span class="attr">payload</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;ADD&#x27;</span>, <span class="attr">payload</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">type</span>: <span class="string">&#x27;ADD&#x27;</span>, <span class="attr">payload</span>: <span class="number">2</span> &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = actions.reduce(reducer, <span class="number">0</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，数组actions表示依次有三个 Action，分别是加0、加1和加2。数组的reduce方法接受 Reducer 函数作为参数，就可以直接得到最终的状态3。</li>
</ul>
<p>3.7 纯函数</p>
<ul>
<li>reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。<br>纯函数是函数式编程的概念，必须遵守以下一些约束。</li>
</ul>
<blockquote>
<p>不得改写参数<br>不能调用系统 I/O 的API<br>不能调用Date.now()或者Math.random()等不纯的方法，因为每次会得到不一样的结果</p>
</blockquote>
<ul>
<li>由于 Reducer 是纯函数，就可以保证同样的State，必定得到同样的 View。但也正因为这一点，Reducer 函数里面不能改变 State，必须返回一个全新的对象，请参考下面的写法。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State 是一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123; thingToChange &#125;);</span><br><span class="line">  <span class="comment">// 或者</span></span><br><span class="line">  <span class="keyword">return</span> &#123; ...state, ...newState &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// State 是一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...state, newItem];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最好把 State 对象设成只读。你没法改变它，要得到新的 State，唯一办法就是生成一个新对象。这样的好处是，任何时候，与某个 View 对应的 State 总是一个不变的对象</li>
</ul>
<p>3.8 store.subscribe()</p>
<ul>
<li>Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br><span class="line"></span><br><span class="line">store.subscribe(listener);</span><br></pre></td></tr></table></figure>

<ul>
<li>store.subscribe方法返回一个函数，调用这个函数就可以解除监听。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsubscribe();</span><br></pre></td></tr></table></figure>

<p>四、Store 的实现</p>
<ul>
<li>可以发现 Store 提供了三个方法。</li>
</ul>
<blockquote>
<p>store.getState()<br>store.dispatch()<br>store.subscribe()</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> &#123; subscribe, dispatch, getState &#125; = createStore(reducer);</span><br></pre></td></tr></table></figure>

<ul>
<li>createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。</li>
</ul>
<h3 id="connect-mapStateToProps-mapDispatchToProps-mergeProps-options"><a href="#connect-mapStateToProps-mapDispatchToProps-mergeProps-options" class="headerlink" title="connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])"></a><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</code></h3><blockquote>
<p>监听store的变化，调用mapStateToProps，返回纯对象，与组件的props合并。</p>
<p>建立state（redux） 和 props（组件）的映射关系，返回一个state和props组合的一个对象</p>
<p>[<code>mapStateToProps(state, [ownProps]): stateProps</code>]  (<em>Function</em>): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，<code>mapStateToProps</code> 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。如果你省略了这个参数，你的组件将不会监听 Redux store。如果指定了该回调函数中的第二个参数 <code>ownProps</code>，则该参数的值为传递到组件的 props，而且只要组件接收到新的 props，<code>mapStateToProps</code> 也会被调用（例如，当 props 接收到来自父组件一个小小的改动，那么你所使用的 ownProps 参数，mapStateToProps 都会被重新计算）。</p>
</blockquote>
<blockquote>
<p>[<code>mapDispatchToProps(dispatch, [ownProps]): dispatchProps</code>] (<em>Object</em> or <em>Function</em>): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中<code>dispatch</code>方法会将action creator的返回值作为参数执行。这些属性会被合并到组件的 props 中。</p>
</blockquote>
<h3 id="createStore-reducer-preloadedState-enhancer"><a href="#createStore-reducer-preloadedState-enhancer" class="headerlink" title="createStore(reducer, [preloadedState], enhancer)"></a>createStore(reducer, [preloadedState], enhancer)</h3><h3 id="combineReducers-reducers"><a href="#combineReducers-reducers" class="headerlink" title="combineReducers(reducers)"></a>combineReducers(reducers)</h3><ul>
<li>把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/createStore.html"><code>createStore</code></a> 方法</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/02/Redux/" data-id="cktu3u7s900071ayc0sf68met" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React-Router" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/01/React-Router/" class="article-date">
  <time datetime="2021-01-01T05:09:28.000Z" itemprop="datePublished">2021-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/01/React-Router/">React-Router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S react-router</span><br></pre></td></tr></table></figure>

<ul>
<li>Router组件本身只是一个容器，真正的路由要通过Route组件定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &#123; Router, Route, hashHistory &#125; from &#39;react-router&#39;;</span><br><span class="line"></span><br><span class="line">render((</span><br><span class="line">  &lt;Router history&#x3D;&#123;hashHistory&#125;&gt;</span><br><span class="line">  	&lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&#x2F;&gt;</span><br><span class="line">	  &lt;Route path&#x3D;&quot;&#x2F;repos&quot; component&#x3D;&#123;Repos&#125;&#x2F;&gt;</span><br><span class="line">  	&lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;Router&gt;</span><br><span class="line">), document.getElementById(&#39;app&#39;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，用户访问根路由/（比如<a target="_blank" rel="noopener" href="http://www.example.com/%EF%BC%89%EF%BC%8C%E7%BB%84%E4%BB%B6APP%E5%B0%B1%E4%BC%9A%E5%8A%A0%E8%BD%BD%E5%88%B0document.getElementById(&#39;app&#39;)%E3%80%82%E4%BD%A0%E5%8F%AF%E8%83%BD%E8%BF%98%E6%B3%A8%E6%84%8F%E5%88%B0%EF%BC%8CRouter%E7%BB%84%E4%BB%B6%E6%9C%89%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0history%EF%BC%8C%E5%AE%83%E7%9A%84%E5%80%BChashHistory%E8%A1%A8%E7%A4%BA%EF%BC%8C%E8%B7%AF%E7%94%B1%E7%9A%84%E5%88%87%E6%8D%A2%E7%94%B1URL%E7%9A%84hash%E5%8F%98%E5%8C%96%E5%86%B3%E5%AE%9A%EF%BC%8C%E5%8D%B3URL%E7%9A%84#%E9%83%A8%E5%88%86%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96%E3%80%82%E4%B8%BE%E4%BE%8B%E6%9D%A5%E8%AF%B4%EF%BC%8C%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AEhttp://www.example.com/%EF%BC%8C%E5%AE%9E%E9%99%85%E4%BC%9A%E7%9C%8B%E5%88%B0%E7%9A%84%E6%98%AFhttp://www.example.com/#/%E3%80%82">http://www.example.com/），组件APP就会加载到document.getElementById(&#39;app&#39;)。你可能还注意到，Router组件有一个参数history，它的值hashHistory表示，路由的切换由URL的hash变化决定，即URL的#部分发生变化。举例来说，用户访问http://www.example.com/，实际会看到的是http://www.example.com/#/。</a></li>
</ul>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Router history&#x3D;&#123;hashHistory&#125;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;repos&quot; component&#x3D;&#123;Repos&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Route&gt;</span><br><span class="line">&lt;&#x2F;Router&gt;</span><br><span class="line"></span><br><span class="line">export default React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &#123;this.props.children&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>用户访问/repos时，会先加载App组件，然后在它的内部再加载Repos组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let routes &#x3D; &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;repos&quot; component&#x3D;&#123;Repos&#125;&#x2F;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;about&quot; component&#x3D;&#123;About&#125;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;;</span><br><span class="line"></span><br><span class="line">&lt;Router routes&#x3D;&#123;routes&#125; history&#x3D;&#123;browserHistory&#125;&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>子路由也可以不写在Router组件里面，单独传入Router组件的routes属性。</li>
</ul>
<h3 id="path-属性"><a href="#path-属性" class="headerlink" title="path 属性"></a>path 属性</h3><ul>
<li>Route组件的path属性指定路由的匹配规则。这个属性是可以省略的，这样的话，不管路径是否匹配，总是会加载指定组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Route component&#x3D;&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;inbox&#x2F;messages&#x2F;:id&quot; component&#x3D;&#123;Message&#125; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Route&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path&#x3D;&quot;&#x2F;hello&#x2F;:name&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello&#x2F;michael</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello&#x2F;ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;hello(&#x2F;:name)&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello&#x2F;michael</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;hello&#x2F;ryan</span><br><span class="line"></span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;files&#x2F;*.*&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;hello.jpg</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;hello.html</span><br><span class="line"></span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;files&#x2F;*&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;a</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;a&#x2F;b</span><br><span class="line"></span><br><span class="line">&lt;Route path&#x3D;&quot;&#x2F;**&#x2F;*.jpg&quot;&gt;</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;hello.jpg</span><br><span class="line">&#x2F;&#x2F; 匹配 &#x2F;files&#x2F;path&#x2F;to&#x2F;file.jpg</span><br></pre></td></tr></table></figure>

<ul>
<li>（1）:paramName</li>
</ul>
<blockquote>
<p>:paramName匹配URL的一个部分，直到遇到下一个/、?、#为止。这个路径参数可以通过this.props.params.paramName取出。</p>
</blockquote>
<ul>
<li>（2）()</li>
</ul>
<blockquote>
<p>()表示URL的这个部分是可选的。</p>
</blockquote>
<ul>
<li>（3）*</li>
</ul>
<blockquote>
<p>*匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</p>
</blockquote>
<ul>
<li>（4） **</li>
</ul>
<blockquote>
<p>** 匹配任意字符，直到下一个/、?、#为止。匹配方式是贪婪模式</p>
</blockquote>
<h3 id="IndexRoute-组件"><a href="#IndexRoute-组件" class="headerlink" title="IndexRoute 组件"></a>IndexRoute 组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">export default React.createClass(&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;</span><br><span class="line">      &#123;this.props.children&#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;accounts&quot; component&#x3D;&#123;Accounts&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;statements&quot; component&#x3D;&#123;Statements&#125;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Route&gt;</span><br><span class="line">&lt;&#x2F;Router&gt;</span><br><span class="line"></span><br><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path&#x3D;&quot;&#x2F;&quot; component&#x3D;&#123;App&#125;&gt;</span><br><span class="line">    &lt;IndexRoute component&#x3D;&#123;Home&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;accounts&quot; component&#x3D;&#123;Accounts&#125;&#x2F;&gt;</span><br><span class="line">    &lt;Route path&#x3D;&quot;statements&quot; component&#x3D;&#123;Statements&#125;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;Route&gt;</span><br><span class="line">&lt;&#x2F;Router&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>上面代码中，访问根路径/，不会加载任何子组件。也就是说，App组件的this.props.children，这时是undefined。</p>
</li>
<li><p>因此，通常会采用{this.props.children || <Home/>}这样的写法。这时，Home明明是Accounts和Statements的同级组件，却没有写在Route中。</p>
</li>
<li><p>IndexRoute就是解决这个问题，显式指定Home是根路由的子组件，即指定默认情况下加载的子组件。你可以把IndexRoute想象成某个路径的index.html</p>
</li>
<li><p>IndexRoute组件没有路径参数path</p>
</li>
</ul>
<h3 id="Redirect-组件"><a href="#Redirect-组件" class="headerlink" title="Redirect 组件"></a>Redirect 组件</h3><ul>
<li><Redirect>组件用于路由的跳转，即用户访问一个路由，会自动跳转到另一个路由</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Route path=<span class="string">&quot;inbox&quot;</span> component=&#123;Inbox&#125;&gt;</span><br><span class="line">  &#123;<span class="comment">/* 从 /inbox/messages/:id 跳转到 /messages/:id */</span>&#125;</span><br><span class="line">  ＜Redirect <span class="keyword">from</span>=<span class="string">&quot;messages/:id&quot;</span> to=<span class="string">&quot;/messages/:id&quot;</span> /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="IndexRedirect-组件"><a href="#IndexRedirect-组件" class="headerlink" title="IndexRedirect 组件"></a>IndexRedirect 组件</h3><ul>
<li>IndexRedirect组件用于访问根路由的时候，将用户重定向到某个子组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Route path=<span class="string">&quot;/&quot;</span> component=&#123;App&#125;&gt;</span><br><span class="line">  ＜IndexRedirect to=<span class="string">&quot;/welcome&quot;</span> /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;welcome&quot;</span> component=&#123;Welcome&#125; /&gt;</span><br><span class="line">  &lt;Route path=<span class="string">&quot;about&quot;</span> component=&#123;About&#125; /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><ul>
<li>Link组件用于取代<a>元素，生成一个链接，允许用户点击后跳转到另一个路由。它基本上就是<a>元素的React 版本，可以接收Router的状态</li>
<li>如果希望当前的路由与其他路由有不同样式，这时可以使用Link组件的activeStyle属性</li>
<li>另一种做法是，使用activeClassName指定当前路由的Class</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &lt;ul role=<span class="string">&quot;nav&quot;</span>&gt;</span><br><span class="line">      &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">activeStyle</span>=<span class="string">&#123;&#123;color:</span> &#x27;<span class="attr">red</span>&#x27;&#125;&#125;&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">      &lt;li&gt;<span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/repos&quot;</span> <span class="attr">activeClassName</span>=<span class="string">&quot;active&quot;</span>&gt;</span>Repos<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>&lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="IndexLink"><a href="#IndexLink" class="headerlink" title="IndexLink"></a>IndexLink</h3><ul>
<li>如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。</li>
<li>这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。根路由只会在精确匹配时，才具有activeClassName</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;IndexLink to=<span class="string">&quot;/&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span>&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;/IndexLink&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;Link to=<span class="string">&quot;/&quot;</span> activeClassName=<span class="string">&quot;active&quot;</span> onlyActiveOnIndex=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>实际上，IndexLink就是对Link组件的onlyActiveOnIndex属性的包装</li>
</ul>
<h3 id="histroy-属性"><a href="#histroy-属性" class="headerlink" title="histroy 属性"></a>histroy 属性</h3><ul>
<li><p>Router组件的history属性，用来监听浏览器地址栏的变化，并将URL解析成一个地址对象，供 React Router 匹配。</p>
</li>
<li><p>history属性，一共可以设置三种值。</p>
</li>
</ul>
<blockquote>
<p>browserHistory (如果设为browserHistory，浏览器的路由就不再通过Hash完成了，而显示正常的路径example.com/some/path，背后调用的是浏览器的History API。)<br>hashHistory  (如果设为hashHistory，路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path)<br>createMemoryHistory (createMemoryHistory主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动)</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; hashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;hashHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> history = createMemoryHistory(location)</span><br></pre></td></tr></table></figure>

<h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><ul>
<li>Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？</li>
<li>第一种方法是使用browserHistory.push</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">handleSubmit</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="keyword">const</span> userName = event.target.elements[<span class="number">0</span>].value</span><br><span class="line">    <span class="keyword">const</span> repo = event.target.elements[<span class="number">1</span>].value</span><br><span class="line">    <span class="keyword">const</span> path = <span class="string">`/repos/<span class="subst">$&#123;userName&#125;</span>/<span class="subst">$&#123;repo&#125;</span>`</span></span><br><span class="line">    browserHistory.push(path)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方法是使用context对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for `router` from context</span></span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    router: React.PropTypes.object</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleSubmit</span>(<span class="params">event</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">this</span>.context.router.push(path)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="路由的钩子"><a href="#路由的钩子" class="headerlink" title="路由的钩子"></a>路由的钩子</h3><ul>
<li>每个路由都有Enter和Leave钩子，用户进入或离开该路由时触发</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;Route path=<span class="string">&quot;inbox&quot;</span> component=&#123;Inbox&#125;&gt;</span><br><span class="line">  &lt;Route</span><br><span class="line">    path=<span class="string">&quot;messages/:id&quot;</span></span><br><span class="line">    onEnter=&#123;</span><br><span class="line">      (&#123;params&#125;, replace) =&gt; replace(<span class="string">`/messages/<span class="subst">$&#123;params.id&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  /&gt;</span><br><span class="line">&lt;/Route</span><br></pre></td></tr></table></figure>

<ul>
<li>onEnter钩子还可以用来做认证。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireAuth = <span class="function">(<span class="params">nextState, replace</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!auth.isAdmin()) &#123;</span><br><span class="line">        <span class="comment">// Redirect to Home page if not an Admin</span></span><br><span class="line">        replace(&#123; <span class="attr">pathname</span>: <span class="string">&#x27;/&#x27;</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> AdminRoutes = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">     &lt;Route path=<span class="string">&quot;/admin&quot;</span> component=&#123;Admin&#125; onEnter=&#123;requireAuth&#125; /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当用户离开一个路径的时候，跳出一个提示框，要求用户确认是否离开。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = withRouter(</span><br><span class="line">  React.createClass(&#123;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.props.router.setRouteLeaveHook(</span><br><span class="line">        <span class="built_in">this</span>.props.route,</span><br><span class="line">        <span class="built_in">this</span>.routerWillLeave</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">routerWillLeave</span>(<span class="params">nextLocation</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 返回 false 会继续停留当前页面，</span></span><br><span class="line">      <span class="comment">// 否则，返回一个字符串，会显示给用户，让其自己决定</span></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.state.isSaved)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;确认要离开？&#x27;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，setRouteLeaveHook方法为Leave钩子指定routerWillLeave函数。该方法如果返回false，将阻止路由的切换，否则就返回一个字符串，提示用户决定是否要切换。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/01/React-Router/" data-id="cktu3u7s700051aycb9cz5s9k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React-Hook" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/01/01/React-Hook/" class="article-date">
  <time datetime="2021-01-01T05:09:28.000Z" itemprop="datePublished">2021-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/01/01/React-Hook/">React-Router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Hook简介"><a href="#1-Hook简介" class="headerlink" title="1.Hook简介"></a>1.Hook简介</h2><blockquote>
<p>它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。</p>
<p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState &#125; from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">function Example() &#123;</span><br><span class="line">  &#x2F;&#x2F; 声明一个新的叫做 “count” 的 state 变量 ,当前状态和一个让你更新它的函数</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  const [fruit, setFruit] &#x3D; useState(&#39;banana&#39;);</span><br><span class="line">  const [todos, setTodos] &#x3D; useState([&#123; text: &#39;Learn Hooks&#39; &#125;]);</span><br><span class="line">  const [func, setfunc] &#x3D; useState(() &#x3D;&gt; &#123;</span><br><span class="line">		return &#123;name: &#39;111&#39;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 React 组件中执行过数据获取、订阅或者手动修改过 DOM。我们统一把这些操作称为“副作用”，或者简称为“作用”。</p>
<p><code>useEffect</code> 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 具有相同的用途，只不过被合并成了一个 API</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;</span><br><span class="line">function Example() &#123;</span><br><span class="line">  const [count, setCount] &#x3D; useState(0);</span><br><span class="line">  &#x2F;&#x2F; 相当于 componentDidMount 和 componentDidUpdate:  </span><br><span class="line">  useEffect(() &#x3D;&gt; &#123;   </span><br><span class="line">    &#x2F;&#x2F; 使用浏览器的 API 更新页面标题  </span><br><span class="line">    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;</span><br><span class="line">  &#125;);</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="hook使用规则"><a href="#hook使用规则" class="headerlink" title="hook使用规则"></a>hook使用规则</h4><p>Hook 就是 JavaScript 函数，但是使用它们会有两个额外的规则：</p>
<ul>
<li>只能在<strong>函数最外层</strong>调用 Hook。不要在循环、条件判断或者子函数中调用。</li>
<li>只能在 <strong>React 的函数组件</strong>中调用 Hook。不要在其他 JavaScript 函数中调用。</li>
</ul>
<h4 id="自定义hook"><a href="#自定义hook" class="headerlink" title="自定义hook"></a>自定义hook</h4><blockquote>
<p>组件之间重用一些状态逻辑</p>
<blockquote>
<p>高阶组件</p>
<p>render props</p>
</blockquote>
</blockquote>
<h2 id="1-useState"><a href="#1-useState" class="headerlink" title="1.useState"></a>1.useState</h2><h2 id="2-useEffect"><a href="#2-useEffect" class="headerlink" title="2.useEffect"></a>2.useEffect</h2><p>1.componentDidMount ,componentDidUpdate,componentWillUnMount </p>
<p>2.数据获取、订阅或者手动修改过 DOM（副作用）dom操作，数据请求，组件更新</p>
<p>3.useeffect(回调函数，数组（可不写）)</p>
<p>4.无阻塞更新</p>
<p>5.多个useeffect</p>
<p>6.useeffect为什么在组件函数内部执行？（可以获取props和state，采用闭包的形式）</p>
<h2 id="3-useRef"><a href="#3-useRef" class="headerlink" title="3.useRef"></a>3.useRef</h2><h2 id="4-useContext"><a href="#4-useContext" class="headerlink" title="4.useContext"></a>4.useContext</h2><blockquote>
<p><code>useContext(MyContext)</code> 只是让你能够<em>读取</em> context 的值以及订阅 context 的变化。你仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件<em>提供</em> context。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">const themes &#x3D; &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: &quot;#000000&quot;,</span><br><span class="line">    background: &quot;#eeeeee&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: &quot;#ffffff&quot;,</span><br><span class="line">    background: &quot;#222222&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const ThemeContext &#x3D; React.createContext(themes.light);</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Provider value&#x3D;&#123;themes.dark&#125;&gt;</span><br><span class="line">      &lt;Toolbar &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;ThemeContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ThemedButton() &#123;</span><br><span class="line">  &#x2F;&#x2F;接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值</span><br><span class="line">  const theme &#x3D; useContext(ThemeContext);</span><br><span class="line">  return (</span><br><span class="line">    &lt;button style&#x3D;&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt;</span><br><span class="line">      I am styled by theme context!</span><br><span class="line">    &lt;&#x2F;button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-useMemo"><a href="#5-useMemo" class="headerlink" title="5.useMemo"></a>5.useMemo</h2><blockquote>
<p><code>shouldcomponentupdate</code>类型，避免渲染过程中重复渲染</p>
<p>当状态或者父组件传来的属性变化时，更新组件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收两个参数，第一个是函数，第二个是数组（非必填）</span><br><span class="line">const memoizedValue &#x3D; useMemo(() &#x3D;&gt; computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>usememo</code>使用<code>memoization</code>来提高性能</li>
<li><code>memoization</code>是<code>javascript</code>的一种缓存技术</li>
</ul>
<h2 id="6-useCallback"><a href="#6-useCallback" class="headerlink" title="6.useCallback"></a>6.useCallback</h2><blockquote>
<p>1.避免组件重复渲染</p>
<p>2.控制组件什么时候更新</p>
</blockquote>
<ul>
<li>useCallback缓存的是一个函数 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;接收两个参数，第一个是函数，第二个是数组（非必填）</span><br><span class="line">&#x2F;&#x2F;函数不会更新 </span><br><span class="line">const memoizedCallback &#x3D; useCallback(</span><br><span class="line">  () &#x3D;&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h2 id="7-useimperativeHandle"><a href="#7-useimperativeHandle" class="headerlink" title="7.useimperativeHandle"></a>7.useimperativeHandle</h2><blockquote>
<p>可以让你在使用 <code>ref</code> 时自定义暴露给父组件的实例值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.REF 2.函数，3.数组？</span><br><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function FancyInput(props, ref) &#123;</span><br><span class="line">  const inputRef &#x3D; useRef();</span><br><span class="line">  useImperativeHandle(ref, () &#x3D;&gt; (&#123;</span><br><span class="line">    focus: () &#x3D;&gt; &#123;</span><br><span class="line">      inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  return &lt;input ref&#x3D;&#123;inputRef&#125; ... &#x2F;&gt;;</span><br><span class="line">&#125;</span><br><span class="line">FancyInput &#x3D; forwardRef(FancyInput);</span><br></pre></td></tr></table></figure>

<h2 id="8-useLayoutEffect"><a href="#8-useLayoutEffect" class="headerlink" title="8.useLayoutEffect"></a>8.useLayoutEffect</h2><blockquote>
<p>与useEffect作用相同，再组件生成过程中进行一些操作</p>
<p>执行的时间不同</p>
<p><code>useLayoutEffect</code>    在浏览器绘制之前执行</p>
<p><code>useEffect</code>在<code>componentdidmount</code>以后执行</p>
</blockquote>
<h2 id="9-useReducer"><a href="#9-useReducer" class="headerlink" title="9.useReducer"></a>9.useReducer</h2><blockquote>
<p>在某些场景下，<code>useReducer</code> 会比 <code>useState</code> 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 <code>useReducer</code> 还能给那些会触发深更新的组件做性能优化，因为<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down">你可以向子组件传递 <code>dispatch</code> 而不是回调函数</a> 。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1.函数reducer,2.初始值，3.init</span><br><span class="line">&#x2F;&#x2F;返回一个数组 [state, dispatch] </span><br><span class="line">const [state, dispatch] &#x3D; useReducer(reducer, initialArg, init);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const initialState &#x3D; &#123;count: 0&#125;;</span><br><span class="line"></span><br><span class="line">function reducer(state, action) &#123;</span><br><span class="line">  switch (action.type) &#123;</span><br><span class="line">    case &#39;increment&#39;:</span><br><span class="line">      return &#123;count: state.count + 1&#125;;</span><br><span class="line">    case &#39;decrement&#39;:</span><br><span class="line">      return &#123;count: state.count - 1&#125;;</span><br><span class="line">    default:</span><br><span class="line">      throw new Error();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Counter() &#123;</span><br><span class="line">  &#x2F;&#x2F;reducer (state, action) &#x3D;&gt; newState</span><br><span class="line">  &#x2F;&#x2F;返回当前的 state 以及与其配套的 dispatch 方法。</span><br><span class="line">  const [state, dispatch] &#x3D; useReducer(reducer, initialState);</span><br><span class="line">  return (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      Count: &#123;state.count&#125;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;decrement&#39;&#125;)&#125;&gt;-&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123;type: &#39;increment&#39;&#125;)&#125;&gt;+&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-usedebugvalue"><a href="#10-usedebugvalue" class="headerlink" title="10.usedebugvalue"></a>10.usedebugvalue</h2><blockquote>
<p><code>useDebugValue</code> 可用于在 React 开发者工具中显示自定义 hook 的标签。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function useFriendStatus(friendID) &#123;</span><br><span class="line">  const [isOnline, setIsOnline] &#x3D; useState(null);</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  &#x2F;&#x2F; 在开发者工具中的这个 Hook 旁边显示标签 </span><br><span class="line">  &#x2F;&#x2F; e.g. &quot;FriendStatus: Online&quot; </span><br><span class="line">  useDebugValue(isOnline ? &#39;Online&#39; : &#39;Offline&#39;);</span><br><span class="line">  return isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(date, date &#x3D;&gt; date.toDateString());</span><br></pre></td></tr></table></figure>





<h2 id="11-自定义hook"><a href="#11-自定义hook" class="headerlink" title="11.自定义hook"></a>11.自定义hook</h2><blockquote>
<p><strong>自定义 Hook 是一个函数，其名称以 “<code>use</code>” 开头，函数内部可以调用其他的 Hook。</strong></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/01/React-Hook/" data-id="cktu3u7s800061ayc8r3zheiq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-React" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/12/26/React/" class="article-date">
  <time datetime="2020-12-26T05:47:17.000Z" itemprop="datePublished">2020-12-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/12/26/React/">React</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-jsx优点"><a href="#1-jsx优点" class="headerlink" title="1.jsx优点"></a>1.jsx优点</h2><ul>
<li><p>执行更快，编译js代码优化</p>
</li>
<li><p>类型更加安全，编译过程出错就不能编译，及时发现错误</p>
</li>
<li><p>jsx便携更加简单快速（没有vue好)</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3></li>
<li><p>jsx必须有根节点</p>
</li>
<li><p>html元素要小写，大写则会被当作组件</p>
</li>
<li><p>使用 <code>camelCase</code>（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定</p>
</li>
<li><p>添加组件属性，有一个地方需要注意，就是 class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字</p>
</li>
<li><p>this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。它表示组件的所有子节点</p>
</li>
<li><p>这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array.</p>
</li>
</ul>
<blockquote>
<p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; (</span><br><span class="line">  &lt;h1 className&#x3D;&quot;greeting&quot;&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;&#x2F;h1&gt;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;完全等效</span><br><span class="line">const element &#x3D; React.createElement(</span><br><span class="line">  &#39;h1&#39;,</span><br><span class="line">  &#123;className: &#39;greeting&#39;&#125;,</span><br><span class="line">  &#39;Hello, world!&#39;</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="深入jsx"><a href="#深入jsx" class="headerlink" title="深入jsx"></a>深入jsx</h4><ul>
<li>1.jsx类型中使用点语法</li>
<li>2.用户定义的组件必须已大写字母开头<ul>
<li>以小写字母开头的元素代表一个 HTML 内置组件，</li>
<li>大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件</li>
</ul>
</li>
<li>3.可以将表达式作为prop</li>
<li>4.props默认为true</li>
<li>5.可以使用字符串字面量</li>
<li>6.使用…来实现属性展开</li>
<li>7.react必须在作用域内<ul>
<li>由于 JSX 会编译为 <code>React.createElement</code> 调用形式，所以 <code>React</code> 库也必须包含在 JSX 代码作用域内。</li>
</ul>
</li>
<li>8.布尔类型、Null 以及 Undefined 将会忽略(不会被渲染)<ul>
<li>如果你想渲染 <code>false</code>、<code>true</code>、<code>null</code>、<code>undefined</code> 等值，你需要先将它们<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion">转换为字符串</a>：</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line"></span><br><span class="line">const MyComponents &#x3D; &#123;</span><br><span class="line">  DatePicker: function DatePicker(props) &#123;</span><br><span class="line">    return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function BlueDatePicker() &#123;</span><br><span class="line">  return &lt;MyComponents.DatePicker color&#x3D;&quot;blue&quot; &#x2F;&gt;;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &#39;.&#x2F;stories&#39;;</span><br><span class="line"></span><br><span class="line">const components &#x3D; &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 错误！JSX 类型不能是一个表达式。  </span><br><span class="line">  return &lt;components[props.storyType] story&#x3D;&#123;props.story&#125; &#x2F;&gt;;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &#39;.&#x2F;stories&#39;;</span><br><span class="line"></span><br><span class="line">const components &#x3D; &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 正确！JSX 类型可以是大写字母开头的变量。  </span><br><span class="line">  const SpecificStory &#x3D; components[props.storyType]; </span><br><span class="line">  return &lt;SpecificStory story&#x3D;&#123;props.story&#125; &#x2F;&gt;;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;值得注意的是有一些 “falsy” 值，如数字 0，仍然会被 React 渲染。</span><br><span class="line">&#x2F;&#x2F;确保 &amp;&amp; 之前的表达式总是布尔值</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;props.messages.length &amp;&amp;    &lt;MessageList messages&#x3D;&#123;props.messages&#125; &#x2F;&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>





<h2 id="2-函数式组件-amp-类组件的区别"><a href="#2-函数式组件-amp-类组件的区别" class="headerlink" title="2.函数式组件 &amp; 类组件的区别"></a>2.函数式组件 &amp; 类组件的区别</h2><ul>
<li><strong>语法上：</strong>函数组件是一个纯函数，它接收一个props对象返回一个react元素；而类组件需要去继承React.Component并且创建render函数返回react元素。</li>
<li><strong>状态管理：</strong>因为函数组件是一个纯函数，你不能在组件中使用<code>setState()</code>，这也是为什么把函数组件称作为无状态组件。</li>
<li><strong>生命周期钩子：</strong>你不能在函数组件中使用生命周期钩子，原因和不能使用<code>state</code>一样，所有的生命周期钩子都来自于继承的<code>React.Component</code>中。</li>
<li><strong>调用方式：</strong>如果<code>SayHi</code>是一个函数，<code>React</code>需要调用它；如果<code>SayHi</code>是一个类，<code>React</code>需要先用<code>new</code>操作符将其实例化，然后调用刚才生成实例的<code>render</code>方法</li>
</ul>
<h2 id="3-props-amp-state"><a href="#3-props-amp-state" class="headerlink" title="3.props &amp; state"></a>3.props &amp; state</h2><blockquote>
<p><strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。</strong></p>
<p>State 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。</p>
</blockquote>
<h2 id="4-事件处理"><a href="#4-事件处理" class="headerlink" title="4.事件处理"></a>4.事件处理</h2><ul>
<li><p>React 事件的命名采用小驼峰式（camelCase），而不是纯小写。</p>
</li>
<li><p>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</p>
</li>
<li><p>不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code></p>
</li>
<li><pre><code class="react">//为了在回调中使用 `this`，这个绑定是必不可少的
this.handleClick = this.handleClick.bind(this);
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;react</span><br><span class="line">  class LoggingButton extends React.Component &#123;</span><br><span class="line">    &#x2F;&#x2F; 此语法确保 &#96;handleClick&#96; 内的 &#96;this&#96; 已被绑定。 </span><br><span class="line">    &#x2F;&#x2F; 注意: 这是 *实验性* 语法。 </span><br><span class="line">    handleClick &#x3D; () &#x3D;&gt; &#123;    console.log(&#39;this is:&#39;, this);  &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return (</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;</span><br><span class="line">          Click me</span><br><span class="line">        &lt;&#x2F;button&gt;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><pre><code class="react">class LoggingButton extends React.Component &#123;
  handleClick() &#123;
    console.log(&#39;this is:&#39;, this);
  &#125;

  render() &#123;
    //在回调中使用箭头函数
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。   
    return (&lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt; 
                    Click me
                  &lt;/button&gt;
    );
  &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5.条件渲染</span><br><span class="line"></span><br><span class="line">&gt; React 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 [&#96;if&#96;](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Statements&#x2F;if...else) 或者[条件运算符](https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en&#x2F;docs&#x2F;Web&#x2F;JavaScript&#x2F;Reference&#x2F;Operators&#x2F;Conditional_Operator)去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;react</span><br><span class="line">function Greeting(props) &#123;</span><br><span class="line">  const isLoggedIn &#x3D; props.isLoggedIn;</span><br><span class="line">  if (isLoggedIn) &#123;</span><br><span class="line">    return &lt;UserGreeting &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;GuestGreeting &#x2F;&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</code></pre>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;阻止组件渲染</span><br><span class="line">&#x2F;&#x2F; render 方法直接返回 null，而不进行任何渲染</span><br><span class="line">&#x2F;&#x2F;在组件的 render 方法中返回 null 并不会影响组件的生命周期。</span><br><span class="line">function WarningBanner(props) &#123;</span><br><span class="line">  if (!props.warn) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;warning&quot;&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="6-列表-amp-key"><a href="#6-列表-amp-key" class="headerlink" title="6.列表&amp;key"></a>6.列表&amp;key</h2><h2 id="7-react组件api"><a href="#7-react组件api" class="headerlink" title="7.react组件api"></a>7.react组件api</h2><ul>
<li><p>设置状态：setState</p>
<ul>
<li><pre><code class="react">setState(object nextState[, function callback])
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **nextState**，将要设置的新状态，该状态会和当前的**state**合并</span><br><span class="line"></span><br><span class="line">  - **callback**，可选参数，回调函数。该函数会在**setState**设置成功，且组件重新渲染后调用。</span><br><span class="line"></span><br><span class="line">  - 不能在组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。</span><br><span class="line"></span><br><span class="line">  - setState()并不会立即改变this.state，而是创建一个即将处理的state。</span><br><span class="line"></span><br><span class="line">  - setState()并不一定是同步的，为了提升性能React会批量执行state和DOM渲染。</span><br><span class="line"></span><br><span class="line">  - setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。</span><br><span class="line"></span><br><span class="line">- 替换状态：replaceState</span><br><span class="line"></span><br><span class="line">  - **replaceState()**方法与**setState()**类似，但是方法只会保留**nextState**中状态，原**state**不在**nextState**中的状态都会被删除。</span><br><span class="line"></span><br><span class="line">- 设置属性：setProps</span><br><span class="line"></span><br><span class="line">  - **props**相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知**React.render()**组件需要重新渲染，可以使用**setProps()**。</span><br><span class="line"></span><br><span class="line">- 替换属性：replaceProps</span><br><span class="line"></span><br><span class="line">  - **replaceProps()**方法与**setProps**类似，但它会删除原有 props。</span><br><span class="line"></span><br><span class="line">- 强制更新：forceUpdate</span><br><span class="line"></span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">    forceUpdate([function callback])</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render()。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。</p>
</li>
<li><p>forceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render()</p>
<p>一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。</p>
</li>
</ul>
</li>
<li><p>获取DOM节点：findDOMNode</p>
<ul>
<li>如果组件已经挂载到DOM中，该方法返回对应的本地浏览器 DOM 元素。</li>
</ul>
</li>
<li><p>判断组件挂载状态：isMounted(isMounted 的方法在 ES6 中已经废除。)</p>
<ul>
<li>返回值：<strong>true</strong>或<strong>false</strong>，表示组件是否已挂载到DOM中</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">    this.mounted &#x3D; true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    this.mounted &#x3D; false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-react生命周期"><a href="#8-react生命周期" class="headerlink" title="8.react生命周期"></a>8.react生命周期</h2><ul>
<li>componentWillMount()——在初始渲染发生之前，即在React将组件插入DOM之前立即调用一次。请务必注意，在此方法中调用 this.setState() 不会触发重新渲染。</li>
<li>componentDidMount()——在渲染函数之后触发此方法。现在可以访问更新的DOM，这意味着该方法是初始化其他需要访问DOM 的 Javascript 库以及数据提取操作的最佳选择。</li>
<li>componentWillReceiveProps()——componentWillReceiveProps()在组件接收新props时调用。在调用render()方法之前，我们可以用这个方法对prop过渡做出反应。在此函数中调用 this.setState() 不会触发额外的重新渲染，我们可以通过this.props访问旧的 props。</li>
<li>shouldComponentUpdate()——我们可以用它来决定下一个组件的状态是否应触发重新渲染。此方法返回一个布尔值，默认为true。但是我们可以返回false，并且不会调用以下方法：</li>
<li>componentWillUpdate()——当接收到新的 props 或状态时，在渲染（更新）之前立即调用此方法。我们可以用它在更新之前做准备，但是不允许使用this.setState()。</li>
<li>componentDidUpdate()——React 更新 DOM 后立即调用此方法。我们可以使用此方法与更新后的 DOM 交互，或执行任何渲染后操作。</li>
<li>componentWillUnmount()——从DOM卸载组件之前立即调用此方法。我们可以用它执行可能需要的任何清理工作。</li>
</ul>
<h2 id="9-Refs转发"><a href="#9-Refs转发" class="headerlink" title="9.Refs转发"></a>9.Refs转发</h2><blockquote>
<p>Ref 转发是一项将 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">ref</a> 自动地通过组件传递到其一子组件的技巧。（组件接收ref,将它交给子组件使用）</p>
<p>1.转发refs到dom组件</p>
<p>2.在高阶组件中转发refs</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const FancyButton &#x3D; React.forwardRef((props, ref) &#x3D;&gt; (  &lt;button ref&#x3D;&#123;ref&#125; className&#x3D;&quot;FancyButton&quot;&gt;    &#123;props.children&#125;</span><br><span class="line">  &lt;&#x2F;button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 你可以直接获取 DOM button 的 ref：</span><br><span class="line">const ref &#x3D; React.createRef();</span><br><span class="line">&lt;FancyButton ref&#x3D;&#123;ref&#125;&gt;Click me!&lt;&#x2F;FancyButton&gt;;</span><br></pre></td></tr></table></figure>

<ol>
<li>我们通过调用 <code>React.createRef</code> 创建了一个 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html">React ref</a> 并将其赋值给 <code>ref</code> 变量。</li>
<li>我们通过指定 <code>ref</code> 为 JSX 属性，将其向下传递给 <code>&lt;FancyButton ref=&#123;ref&#125;&gt;</code>。</li>
<li>React 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) =&gt; ...</code>，作为其第二个参数。</li>
<li>我们向下转发该 <code>ref</code> 参数到 <code>&lt;button ref=&#123;ref&#125;&gt;</code>，将其指定为 JSX 属性。</li>
<li>当 ref 挂载完成，<code>ref.current</code> 将指向 <code>&lt;button&gt;</code> DOM 节点。</li>
</ol>
<blockquote>
<p>第二个参数 <code>ref</code> 只在使用 <code>React.forwardRef</code> 定义组件时存在。常规函数和 class 组件不接收 <code>ref</code> 参数，且 props 中也不存在 <code>ref</code>。</p>
<p>Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。</p>
</blockquote>
<h2 id="10-React-lazy-尚未支持"><a href="#10-React-lazy-尚未支持" class="headerlink" title="10.React.lazy 尚未支持"></a>10.React.lazy 尚未支持</h2><blockquote>
<p>注意:</p>
<p><code>React.lazy</code> 和 Suspense 技术还不支持服务端渲染。如果你想要在使用服务端渲染的应用中使用，我们推荐 <a target="_blank" rel="noopener" href="https://github.com/gregberge/loadable-components">Loadable Components</a> 这个库。它有一个很棒的<a target="_blank" rel="noopener" href="https://loadable-components.com/docs/server-side-rendering/">服务端渲染打包指南</a>。</p>
<p><code>React.lazy</code> 函数能让你像渲染常规组件一样处理动态引入（的组件）。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用之前</span><br><span class="line">import OtherComponent from &#39;.&#x2F;OtherComponent&#39;;</span><br><span class="line">&#x2F;&#x2F;使用之后</span><br><span class="line">&#x2F;&#x2F;React.lazy 接受一个函数，这个函数需要动态调用 import()。</span><br><span class="line">&#x2F;&#x2F;它必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件。</span><br><span class="line">const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));</span><br></pre></td></tr></table></figure>

<h2 id="11-错误边界"><a href="#11-错误边界" class="headerlink" title="11.错误边界"></a>11.错误边界</h2><blockquote>
<p>错误边界是一种 React 组件，这种组件<strong>可以捕获发生在其子组件树任何位置的 JavaScript 错误，并打印这些错误，同时展示降级 UI</strong>，而并不会渲染那些发生崩溃的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。</p>
</blockquote>
<blockquote>
<p>注意</p>
<p>错误边界<strong>无法</strong>捕获以下场景中产生的错误：</p>
<ul>
<li>事件处理（<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/error-boundaries.html#how-about-event-handlers">了解更多</a>）</li>
<li>异步代码（例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 回调函数）</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（并非它的子组件）</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;</span><br><span class="line">    &#x2F;&#x2F; 更新 state 使下一次渲染能够显示降级后的 UI</span><br><span class="line">    return &#123; hasError: true &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, errorInfo) &#123;</span><br><span class="line">    &#x2F;&#x2F; 你同样可以将错误日志上报给服务器</span><br><span class="line">    logErrorToMyService(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;</span><br><span class="line">      &#x2F;&#x2F; 你可以自定义降级后的 UI 并渲染</span><br><span class="line">      return &lt;h1&gt;Something went wrong.&lt;&#x2F;h1&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return this.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="12-高阶组件"><a href="#12-高阶组件" class="headerlink" title="12. 高阶组件"></a>12. 高阶组件</h2><blockquote>
<p>具体而言，<strong>高阶组件是参数为组件，返回值为新组件的函数。</strong></p>
</blockquote>
<blockquote>
<p>1.高阶组件可以接收所有props</p>
<p>2.可以使用 <code>React.forwardRef</code> API 明确地将 refs 转发到子组件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function logProps(Component) &#123;</span><br><span class="line">  class LogProps extends React.Component &#123;</span><br><span class="line">    componentDidUpdate(prevProps) &#123;</span><br><span class="line">      console.log(&#39;old props:&#39;, prevProps);</span><br><span class="line">      console.log(&#39;new props:&#39;, this.props);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      const &#123;forwardedRef, ...rest&#125; &#x3D; this.props;</span><br><span class="line">      &#x2F;&#x2F; 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span><br><span class="line">      return &lt;Component ref&#x3D;&#123;forwardedRef&#125; &#123;...rest&#125; &#x2F;&gt;;    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 注意 React.forwardRef 回调的第二个参数 “ref”。</span><br><span class="line">  &#x2F;&#x2F; 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span><br><span class="line">  &#x2F;&#x2F; 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span><br><span class="line">  return React.forwardRef((props, ref) &#x3D;&gt; &#123;    return &lt;LogProps &#123;...props&#125; forwardedRef&#x3D;&#123;ref&#125; &#x2F;&gt;;  &#125;);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><blockquote>
<p>1.将不相关的 props 传递给被包裹的组件</p>
<p>2.不再高阶组件中修改原型，使用组合（会导致与其他高阶组件产生冲突）</p>
<p>3.最大化可组合性</p>
<p>4.包装显示名称以便轻松调试</p>
<p>5.不要再render方法中使用高阶组件</p>
<p>6.refs不会被传递</p>
<p>7.务必复制静态方法</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import hoistNonReactStatic from &#39;hoist-non-react-statics&#39;;</span><br><span class="line">function enhance(WrappedComponent) &#123;</span><br><span class="line">  class Enhance extends React.Component &#123;&#x2F;*...*&#x2F;&#125;</span><br><span class="line">  &#x2F;&#x2F; 必须准确知道应该拷贝哪些方法 </span><br><span class="line">  Enhance.staticMethod &#x3D; WrappedComponent.staticMethod;</span><br><span class="line">  &#x2F;&#x2F;使用hoistNonReactStatic自动拷贝所有非 React 静态方法:</span><br><span class="line">  hoistNonReactStatic(Enhance, WrappedComponent);</span><br><span class="line">  return Enhance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>除了导出组件，另一个可行的方案是再额外导出这个静态方法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用这种方式代替...</span><br><span class="line">MyComponent.someFunction &#x3D; someFunction;</span><br><span class="line">export default MyComponent;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...单独导出该方法...</span><br><span class="line">export &#123; someFunction &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...并在要使用的组件中，import 它们</span><br><span class="line">import MyComponent, &#123; someFunction &#125; from &#39;.&#x2F;MyComponent.js&#39;;</span><br></pre></td></tr></table></figure>

<h2 id="14-与第三方库协同-todo"><a href="#14-与第三方库协同-todo" class="headerlink" title="14.与第三方库协同-todo"></a>14.与第三方库协同-todo</h2><pre><code>#### 14-1 集成带有dom操作的插件</code></pre>
<blockquote>
<p>React 不会理会 React 自身之外的 DOM 操作。它根据内部虚拟 DOM 来决定是否需要更新，而且如果同一个 DOM 节点被另一个库操作了，React 会觉得困惑而且没有办法恢复。</p>
</blockquote>
<h2 id="15-性能优化"><a href="#15-性能优化" class="headerlink" title="15.性能优化"></a>15.性能优化</h2><ul>
<li><p>虚拟化长列表</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://react-window.now.sh/">react-window</a> 和 <a target="_blank" rel="noopener" href="https://bvaughn.github.io/react-virtualized/">react-virtualized</a> 是热门的虚拟滚动库。 它们提供了多种可复用的组件，用于展示列表、网格和表格数据。 如果你想要一些针对你的应用做定制优化，你也可以创建你自己的虚拟滚动组件，就像 <a target="_blank" rel="noopener" href="https://medium.com/@paularmstrong/twitter-lite-and-high-performance-react-progressive-web-apps-at-scale-d28a00e780a3">Twitter 所做的</a>。</li>
</ul>
</li>
<li><p>避免调停</p>
</li>
<li><p>shouldComponentUpdate 的作用</p>
</li>
<li><p>使用开发者工具中的分析器对组件进行分析</p>
</li>
<li><p>不改变原来的数据</p>
<ul>
<li> <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign</a> 方法：</li>
<li>拓展运算符等其他返回一个新数据等方法</li>
</ul>
</li>
</ul>
<h1 id="16-Portals"><a href="#16-Portals" class="headerlink" title="16.Portals"></a>16.Portals</h1><blockquote>
<p>Portal 提供了一种将子节点渲染到存在于父组件以外的 DOM 节点的优秀的方案。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container)</span><br><span class="line">&#x2F;&#x2F;child 是任何可渲染的 React 子元素</span><br><span class="line">&#x2F;&#x2F;container 是一个 DOM 元素</span><br><span class="line">&#x2F;&#x2F;将 child 指定到想要渲染的 container 中去</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个 portal 的典型用例是当父组件有 <code>overflow: hidden</code> 或 <code>z-index</code> 样式时，但你需要子组件能够在视觉上“跳出”其容器。例如，对话框、悬浮卡以及提示框：</p>
</blockquote>
<h4 id="使用portals进行事件冒泡"><a href="#使用portals进行事件冒泡" class="headerlink" title="使用portals进行事件冒泡"></a>使用portals进行事件冒泡</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在 DOM 中有两个容器是兄弟级 （siblings）</span><br><span class="line">const appRoot &#x3D; document.getElementById(&#39;app-root&#39;);</span><br><span class="line">const modalRoot &#x3D; document.getElementById(&#39;modal-root&#39;);</span><br><span class="line"></span><br><span class="line">class Modal extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.el &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    &#x2F;&#x2F; 在 Modal 的所有子元素被挂载后，</span><br><span class="line">    &#x2F;&#x2F; 这个 portal 元素会被嵌入到 DOM 树中，</span><br><span class="line">    &#x2F;&#x2F; 这意味着子元素将被挂载到一个分离的 DOM 节点中。</span><br><span class="line">    &#x2F;&#x2F; 如果要求子组件在挂载时可以立刻接入 DOM 树，</span><br><span class="line">    &#x2F;&#x2F; 例如衡量一个 DOM 节点，</span><br><span class="line">    &#x2F;&#x2F; 或者在后代节点中使用 ‘autoFocus’，</span><br><span class="line">    &#x2F;&#x2F; 则需添加 state 到 Modal 中，</span><br><span class="line">    &#x2F;&#x2F; 仅当 Modal 被插入 DOM 树中才能渲染子元素。</span><br><span class="line">    modalRoot.appendChild(this.el);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    modalRoot.removeChild(this.el);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return ReactDOM.createPortal(      this.props.children,      this.el    );  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state &#x3D; &#123;clicks: 0&#125;;</span><br><span class="line">    this.handleClick &#x3D; this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;    &#x2F;&#x2F; 当子元素里的按钮被点击时，    &#x2F;&#x2F; 这个将会被触发更新父元素的 state，    &#x2F;&#x2F; 即使这个按钮在 DOM 中不是直接关联的后代    this.setState(state &#x3D;&gt; (&#123;      clicks: state.clicks + 1    &#125;));  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div onClick&#x3D;&#123;this.handleClick&#125;&gt;        &lt;p&gt;Number of clicks: &#123;this.state.clicks&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          Open up the browser DevTools</span><br><span class="line">          to observe that the button</span><br><span class="line">          is not a child of the div</span><br><span class="line">          with the onClick handler.</span><br><span class="line">        &lt;&#x2F;p&gt;</span><br><span class="line">        &lt;Modal&gt;          &lt;Child &#x2F;&gt;        &lt;&#x2F;Modal&gt;      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">  &#x2F;&#x2F; 这个按钮的点击事件会冒泡到父元素  &#x2F;&#x2F; 因为这里没有定义 &#39;onClick&#39; 属性  return (</span><br><span class="line">    &lt;div className&#x3D;&quot;modal&quot;&gt;</span><br><span class="line">      &lt;button&gt;Click&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Parent &#x2F;&gt;, appRoot);</span><br></pre></td></tr></table></figure>



<h1 id="17-Profiler-API"><a href="#17-Profiler-API" class="headerlink" title="17.Profiler API"></a>17.Profiler API</h1><blockquote>
<p><code>Profiler</code> 测量渲染一个 React 应用多久渲染一次以及渲染一次的“代价”。 它的目的是识别出应用中渲染较慢的部分，或是可以使用<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-memoize-calculations">类似 memoization 优化</a>的部分，并从相关优化中获益。</p>
<p><code>Profiler</code> 能添加在 React 树中的任何地方来测量树中这部分渲染所带来的开销。 它需要两个 prop ：一个是 <code>id</code>(string)，一个是当组件树中的组件“提交”更新的时候被React调用的回调函数 <code>onRender</code>(function)。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;App&gt;</span><br><span class="line">    &lt;Profiler id&#x3D;&quot;Navigation&quot; onRender&#x3D;&#123;callback&#125;&gt;    </span><br><span class="line">      &lt;Navigation &#123;...props&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Profiler&gt;</span><br><span class="line">    &lt;Profiler id&#x3D;&quot;Main&quot; onRender&#x3D;&#123;callback&#125;&gt;   </span><br><span class="line">      &lt;Main &#123;...props&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;Profiler&gt;</span><br><span class="line">  &lt;&#x2F;App&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="onRender回调"><a href="#onRender回调" class="headerlink" title="onRender回调"></a>onRender回调</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function onRenderCallback(</span><br><span class="line">  id, &#x2F;&#x2F; 发生提交的 Profiler 树的 “id”</span><br><span class="line">  phase, &#x2F;&#x2F; &quot;mount&quot; （如果组件树刚加载） 或者 &quot;update&quot; （如果它重渲染了）之一</span><br><span class="line">  actualDuration, &#x2F;&#x2F; 本次更新 committed 花费的渲染时间</span><br><span class="line">  baseDuration, &#x2F;&#x2F; 估计不使用 memoization 的情况下渲染整颗子树需要的时间</span><br><span class="line">  startTime, &#x2F;&#x2F; 本次更新中 React 开始渲染的时间</span><br><span class="line">  commitTime, &#x2F;&#x2F; 本次更新中 React committed 的时间</span><br><span class="line">  interactions &#x2F;&#x2F; 属于本次更新的 interactions 的集合</span><br><span class="line">) &#123;</span><br><span class="line">  &#x2F;&#x2F; 合计或记录渲染时间。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>d: string</code></strong> - 发生提交的 <code>Profiler</code> 树的 <code>id</code>。 如果有多个 profiler，它能用来分辨树的哪一部分发生了“提交”。</li>
<li><strong><code>phase: &quot;mount&quot; | &quot;update&quot;</code></strong> - 判断是组件树的第一次装载引起的重渲染，还是由 props、state 或是 hooks 改变引起的重渲染。</li>
<li><strong><code>actualDuration: number</code></strong> - 本次更新在渲染 <code>Profiler</code> 和它的子代上花费的时间。 这个数值表明使用 memoization 之后能表现得多好。（例如 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/react-api.html#reactmemo"><code>React.memo</code></a>，<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo"><code>useMemo</code></a>，<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-faq.html#how-do-i-implement-shouldcomponentupdate"><code>shouldComponentUpdate</code></a>）。 理想情况下，由于子代只会因特定的 prop 改变而重渲染，因此这个值应该在第一次装载之后显著下降。</li>
<li><strong><code>baseDuration: number</code></strong> - 在 <code>Profiler</code> 树中最近一次每一个组件 <code>render</code> 的持续时间。 这个值估计了最差的渲染时间。（例如当它是第一次加载或者组件树没有使用 memoization）。</li>
<li><strong><code>startTime: number</code></strong> - 本次更新中 React 开始渲染的时间戳。</li>
<li><strong><code>commitTime: number</code></strong> - 本次更新中 React commit 阶段结束的时间戳。 在一次 commit 中这个值在所有的 profiler 之间是共享的，可以将它们按需分组。</li>
<li><strong><code>interactions: Set</code></strong> - 当更新被制定时，<a target="_blank" rel="noopener" href="https://fb.me/react-interaction-tracing">“interactions”</a> 的集合会被追踪。（例如当 <code>render</code> 或者 <code>setState</code> 被调用时）。</li>
</ul>
<h2 id="18-Fragments"><a href="#18-Fragments" class="headerlink" title="18.Fragments"></a>18.Fragments</h2><blockquote>
<p>React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Columns extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;React.Fragment&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;简写使用，不支持 key 或属性。</span><br><span class="line">class Columns extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;td&gt;Hello&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td&gt;World&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;使用显式 &lt;React.Fragment&gt; 语法声明的片段可能具有 key。一个使用场景是将一个集合映射到一个 Fragments 数组 </span><br><span class="line">function Glossary(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &#123;props.items.map(item &#x3D;&gt; (</span><br><span class="line">        &#x2F;&#x2F; 没有&#96;key&#96;，React 会发出一个关键警告</span><br><span class="line">        &lt;React.Fragment key&#x3D;&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;dt&gt;&#123;item.term&#125;&lt;&#x2F;dt&gt;</span><br><span class="line">          &lt;dd&gt;&#123;item.description&#125;&lt;&#x2F;dd&gt;</span><br><span class="line">        &lt;&#x2F;React.Fragment&gt;</span><br><span class="line">      ))&#125;</span><br><span class="line">    &lt;&#x2F;dl&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="19-不实用es6"><a href="#19-不实用es6" class="headerlink" title="19.不实用es6"></a>19.不实用es6</h2><ul>
<li>如果你还未使用过 ES6，你可以使用 <code>create-react-class</code> 模块：</li>
<li>声明默认属性</li>
<li>初始化state</li>
<li>自动绑定<ul>
<li>在 constructor 中绑定方法。</li>
<li>使用箭头函数，比如：<code>onClick=&#123;(e) =&gt; this.handleClick(e)&#125;</code>。</li>
<li>继续使用 <code>createReactClass</code>。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var createReactClass &#x3D; require(&#39;create-react-class&#39;);</span><br><span class="line">var Greeting &#x3D; createReactClass(&#123;</span><br><span class="line">  render: function() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var Counter &#x3D; createReactClass(&#123;</span><br><span class="line">  getInitialState: function() &#123;</span><br><span class="line">    return &#123;count: this.props.initialCount&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h2 id="20-不实用jsx"><a href="#20-不实用jsx" class="headerlink" title="20.不实用jsx"></a>20.不实用jsx</h2><h2 id="21-Diffing-算法-协调算法"><a href="#21-Diffing-算法-协调算法" class="headerlink" title="21.Diffing 算法 (协调算法)"></a>21.Diffing 算法 (协调算法)</h2><blockquote>
<p>在某一时间节点调用 React 的 <code>render()</code> 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 <code>render()</code> 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何高效的更新 UI，以保证当前 UI 与最新的树保持同步。</p>
</blockquote>
<blockquote>
<p>A.当对比两棵树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。</p>
<p>1-1.当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。</p>
<p>1-2.当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 <code>componentWillUnmount()</code> 方法。</p>
<p>2.当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 <code>UNSAFE_componentWillMount()</code> 方法，紧接着 <code>componentDidMount()</code> 方法。所有与之前的树相关联的 state 也会被销毁。</p>
<p>B.当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。(明确自己要修改哪些属性)</p>
<p>1-1在处理完当前节点之后，React 继续对子节点进行递归。</p>
<p>C.当一个组件更新时，组件实例会保持不变，因此可以在不同的渲染时保持 state 一致。</p>
<p>D.递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。</p>
</blockquote>
<h1 id="22-Refs-and-the-DOM"><a href="#22-Refs-and-the-DOM" class="headerlink" title="22.Refs and the DOM"></a>22.Refs and the DOM</h1><blockquote>
<p>Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。</p>
<p>在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。</p>
</blockquote>
<blockquote>
<ul>
<li>何时使用refs</li>
</ul>
<blockquote>
<ul>
<li>管理焦点，文本选择或媒体播放。</li>
<li>触发强制动画。</li>
<li>集成第三方 DOM 库。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="创建refs"><a href="#创建refs" class="headerlink" title="创建refs"></a>创建refs</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyComponent extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.myRef &#x3D; React.createRef();  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div ref&#x3D;&#123;this.myRef&#125; &#x2F;&gt;;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="访问refs"><a href="#访问refs" class="headerlink" title="访问refs"></a>访问refs</h4><p>ref 的值根据节点的类型而有所不同：</p>
<ul>
<li>当 <code>ref</code> 属性用于 HTML 元素时，构造函数中使用 <code>React.createRef()</code> 创建的 <code>ref</code> 接收底层 DOM 元素作为其 <code>current</code> 属性。<ul>
<li>React 会在组件挂载时给 <code>current</code> 属性传入 DOM 元素，并在组件卸载时传入 <code>null</code> 值。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</li>
</ul>
</li>
<li>当 <code>ref</code> 属性用于自定义 class 组件时，<code>ref</code> 对象接收组件的挂载实例作为其 <code>current</code> 属性。</li>
<li><strong>你不能在函数组件上使用 <code>ref</code> 属性</strong>，因为他们没有实例。<ul>
<li>可以<strong>在函数组件内部使用 <code>ref</code> 属性</strong>，只要它指向一个 DOM 元素或 class 组件</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class AutoFocusTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.textInput &#x3D; React.createRef();  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.textInput.current.focusTextInput();  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput ref&#x3D;&#123;this.textInput&#125; &#x2F;&gt;    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">  &#x2F;&#x2F; 这里必须声明 textInput，这样 ref 才可以引用它  const textInput &#x3D; useRef(null);</span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    textInput.current.focus();  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type&#x3D;&quot;text&quot;</span><br><span class="line">        ref&#x3D;&#123;textInput&#125; &#x2F;&gt;      &lt;input</span><br><span class="line">        type&#x3D;&quot;button&quot;</span><br><span class="line">        value&#x3D;&quot;Focus the text input&quot;</span><br><span class="line">        onClick&#x3D;&#123;handleClick&#125;</span><br><span class="line">      &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将-DOM-Refs-暴露给父组件"><a href="#将-DOM-Refs-暴露给父组件" class="headerlink" title="将 DOM Refs 暴露给父组件"></a>将 DOM Refs 暴露给父组件</h3><blockquote>
<p>在极少数情况下，你可能希望在父组件中引用子节点的 DOM 节点。通常不建议这样做，因为它会打破组件的封装，但它偶尔可用于触发焦点或测量子 DOM 节点的大小或位置。</p>
</blockquote>
<h3 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line"></span><br><span class="line">    this.textInput &#x3D; null;</span><br><span class="line">    this.setTextInputRef &#x3D; element &#x3D;&gt; &#123;      this.textInput &#x3D; element;    &#125;;</span><br><span class="line">    this.focusTextInput &#x3D; () &#x3D;&gt; &#123;      &#x2F;&#x2F; 使用原生 DOM API 使 text 输入框获得焦点      if (this.textInput) this.textInput.focus();    &#125;;  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    &#x2F;&#x2F; 组件挂载后，让文本框自动获得焦点</span><br><span class="line">    this.focusTextInput();  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用 &#96;ref&#96; 的回调函数将 text 输入框 DOM 节点的引用存储到 React</span><br><span class="line">    &#x2F;&#x2F; 实例上（比如 this.textInput）</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type&#x3D;&quot;text&quot;</span><br><span class="line">          ref&#x3D;&#123;this.setTextInputRef&#125;        &#x2F;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type&#x3D;&quot;button&quot;</span><br><span class="line">          value&#x3D;&quot;Focus the text input&quot;</span><br><span class="line">          onClick&#x3D;&#123;this.focusTextInput&#125;        &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="23-Render-Props"><a href="#23-Render-Props" class="headerlink" title="23.Render Props"></a>23.Render Props</h1><blockquote>
<p>术语 <a target="_blank" rel="noopener" href="https://cdb.reacttraining.com/use-a-render-prop-50de598f11ce">“render prop”</a> 是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术</p>
<p>具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style&#x3D;&#123;&#123; height: &#39;100vh&#39; &#125;&#125; onMouseMove&#x3D;&#123;this.handleMouseMove&#125;&gt;</span><br><span class="line"></span><br><span class="line">        &#123;&#x2F;*</span><br><span class="line">          使用 &#96;render&#96;prop 动态决定要渲染的内容，</span><br><span class="line">          而不是给出一个 &lt;Mouse&gt; 渲染结果的静态表示</span><br><span class="line">        *&#x2F;&#125;</span><br><span class="line">        &#123;this.props.render(this.state)&#125;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F;render prop 是一个用于告知组件需要渲染什么内容的函数 prop。</span><br><span class="line">class MouseTracker extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;移动鼠标!&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;Mouse render&#x3D;&#123;mouse &#x3D;&gt; (</span><br><span class="line">          &lt;Cat mouse&#x3D;&#123;mouse&#125; &#x2F;&gt;</span><br><span class="line">        )&#125;&#x2F;&gt;</span><br><span class="line">        &lt;Mouse children&#x3D;&#123;mouse &#x3D;&gt; (</span><br><span class="line"> 				 &lt;p&gt;鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;&lt;&#x2F;p&gt;</span><br><span class="line">				)&#125;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-PropTypes"><a href="#24-PropTypes" class="headerlink" title="24.PropTypes"></a>24.PropTypes</h2><ul>
<li>组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">MyTitle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">          title: PropTypes.string.isRequired,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;this.props.title&#125; <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ReactDOM.render(</span><br><span class="line">        &lt;MyTitle title=&#123;data&#125; /&gt;,</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">      );</span><br></pre></td></tr></table></figure>

<h3 id="获取真实的DOM节点"><a href="#获取真实的DOM节点" class="headerlink" title="获取真实的DOM节点"></a>获取真实的DOM节点</h3><ul>
<li><p>组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。根据 React 的设计，所有的 DOM 变动，都先在虚拟 DOM 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 DOM diff ，它可以极大提高网页的性能表现。但是，有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性.（ref是组件的特殊属性，组件被渲染后，指向组件的一个引用。）</p>
</li>
<li><p>需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。上面代码中，通过为组件指定 Click 事件的回调函数，确保了只有等到真实 DOM 发生 Click 事件之后，才会读取 this.refs.[refName] 属性</p>
</li>
</ul>
<h2 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;div&gt;Hello &lt;x-search&gt;&#123;this.props.name&#125;&lt;&#x2F;x-search&gt;!&lt;&#x2F;div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>Web Components 通常暴露的是命令式 API。例如，Web Components 的组件 <code>video</code> 可能会公开 <code>play()</code> 和 <code>pause()</code> 方法。要访问 Web Components 的命令式 API，你需要使用 <code>ref</code> 直接与 DOM 节点进行交互。如果你使用的是第三方 Web Components，那么最好的解决方案是编写 React 组件包装该 Web Components。</p>
<p>Web Components 触发的事件可能无法通过 React 渲染树正确的传递。 你需要在 React 组件中手动添加事件处理器来处理这些事件。</p>
</blockquote>
<h3 id="React-Suspense尚未支持"><a href="#React-Suspense尚未支持" class="headerlink" title="React.Suspense尚未支持"></a><code>React.Suspense</code>尚未支持</h3><p><code>React.Suspense</code> 可以指定加载指示器（loading indicator），以防其组件树中的某些子组件尚未具备渲染条件。目前，懒加载组件是 <code>&lt;React.Suspense&gt;</code> 支持的<strong>唯一</strong>用例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 该组件是动态加载的</span><br><span class="line">const OtherComponent &#x3D; React.lazy(() &#x3D;&gt; import(&#39;.&#x2F;OtherComponent&#39;));</span><br><span class="line"></span><br><span class="line">function MyComponent() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &#x2F;&#x2F; 显示 &lt;Spinner&gt; 组件直至 OtherComponent 加载完成</span><br><span class="line">    &lt;React.Suspense fallback&#x3D;&#123;&lt;Spinner &#x2F;&gt;&#125;&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;OtherComponent &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;React.Suspense&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="何时使用-Context"><a href="#何时使用-Context" class="headerlink" title="何时使用 Context"></a>何时使用 Context</h2><blockquote>
<p>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法</p>
<p>Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。举个例子，在下面的代码中，我们通过一个 “theme” 属性手动调整一个按钮组件的样式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Toolbar theme&#x3D;&quot;dark&quot; &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Toolbar(props) &#123;</span><br><span class="line">  &#x2F;&#x2F; Toolbar 组件接受一个额外的“theme”属性，然后传递给 ThemedButton 组件。</span><br><span class="line">  &#x2F;&#x2F; 如果应用中每一个单独的按钮都需要知道 theme 的值，这会是件很麻烦的事，</span><br><span class="line">  &#x2F;&#x2F; 因为必须将这个值层层传递所有组件。</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton theme&#x3D;&#123;props.theme&#125; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Button theme&#x3D;&#123;this.props.theme&#125; &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 context, 我们可以避免通过中间元素传递 props：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span><br><span class="line">&#x2F;&#x2F; 为当前的 theme 创建一个 context（“light”为默认值）。</span><br><span class="line">const ThemeContext &#x3D; React.createContext(&#39;light&#39;);</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    &#x2F;&#x2F; 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span><br><span class="line">    &#x2F;&#x2F; 无论多深，任何组件都能读取这个值。</span><br><span class="line">    &#x2F;&#x2F; 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span><br><span class="line"></span><br><span class="line">return (</span><br><span class="line">      &lt;ThemeContext.Provider value&#x3D;&quot;dark&quot;&gt;</span><br><span class="line">        &lt;Toolbar &#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 中间的组件再也不必指明往下传递 theme 了。</span><br><span class="line">function Toolbar() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ThemedButton extends React.Component &#123;</span><br><span class="line">  &#x2F;&#x2F; 指定 contextType 读取当前的 theme context。</span><br><span class="line">  &#x2F;&#x2F; React 会往上找到最近的 theme Provider，然后使用它的值。</span><br><span class="line">  &#x2F;&#x2F; 在这个例子中，当前的 theme 值为 “dark”。</span><br><span class="line">  static contextType &#x3D; ThemeContext;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;Button theme&#x3D;&#123;this.context&#125; &#x2F;&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>






      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/12/26/React/" data-id="cktu3u7tg000p1aycgoxb7tpk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2020-11-29T05:48:07.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="提交步骤"><a href="#提交步骤" class="headerlink" title="提交步骤"></a>提交步骤</h3><ul>
<li>hexo g(页面初始化)</li>
<li>hexo d (代码上传)</li>
<li>github账号（1024943528）</li>
</ul>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><ul>
<li>  . 匹配楚换行符以外的任意字符</li>
<li>  \w 匹配字母或数字或下划线或汉字</li>
<li>  \s 匹配任意的空白符</li>
<li>  \d 匹配数字</li>
<li>  \b 匹配单词的开始或结束</li>
<li>  ^ 匹配字符串的开始</li>
<li>  $ 匹配字符串的结束</li>
<li>  *长度任意字符</li>
<li>  ？长度为 1 的字符串</li>
</ul>
<h2 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h2><ul>
<li>  \W 匹配任意不是 字母或数字或下划线或汉字的字符</li>
<li>  \S 匹配任意不是空白符的字符</li>
<li>  \D 匹配任意非数字的字符</li>
<li>  \B 匹配不是单词词的开始或结束的位置</li>
<li>  [^x] 匹配除了 x 以外的任意字符</li>
<li>  [^aeiou] 匹配除了 aeiou 者几个字母以外的任意字符</li>
</ul>
<h2 id="正则表达式中的注释"><a href="#正则表达式中的注释" class="headerlink" title="正则表达式中的注释"></a>正则表达式中的注释</h2><ul>
<li>  启用忽略模式里的空白符</li>
<li>  (?&lt;= 断言要匹配的文本的前缀</li>
<li>  &lt;(\w+)&gt; 查找尖括号括起来的字母或数字(html/xml 标签</li>
<li>  ) 前缀结束</li>
<li>  .* 匹配任意文本</li>
<li>  (?= 断言要匹配的文本的后缀</li>
<li>  &lt;/\1&gt; 查找尖括号括起来的内容</li>
<li>  ) 后缀结束</li>
<li>  [^aeiou] 匹配除了 aeiou 者几个字母以外的任意字符</li>
</ul>
<h2 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h2><ul>
<li>  .</li>
<li>  ?</li>
<li>  *</li>
</ul>
<h2 id="正则表达式中的注释-1"><a href="#正则表达式中的注释-1" class="headerlink" title="正则表达式中的注释"></a>正则表达式中的注释</h2><ul>
<li>  启用忽略模式里的空白符</li>
<li>  (?&lt;= 断言要匹配的文本的前缀</li>
<li>  &lt;(\w+)&gt; 查找尖括号括起来的字母或数字(html/xml 标签</li>
<li>  ) 前缀结束</li>
<li>  .* 匹配任意文本</li>
<li>  (?= 断言要匹配的文本的后缀</li>
<li>  &lt;/\1&gt; 查找尖括号括起来的内容</li>
<li>  ) 后缀结束</li>
<li>  1.字面量写法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/pattern/</span>afgls;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;1024943528@qq.com&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> p = <span class="regexp">/mjj/g</span>;</span><br><span class="line">p.test(str);</span><br></pre></td></tr></table></figure>

<ul>
<li>  2.构造函数写法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;mjjxmx&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;mjj&quot;</span>, <span class="string">&quot;g&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1.test(str));</span><br></pre></td></tr></table></figure>

<ul>
<li>  ^$（位置字符）</li>
<li>  匹配数字和字母,非数字和飞字母（\w,\W）</li>
<li>  匹配数字和非数字（\d,\D）</li>
<li>  匹配空白字符和非空白字符 （\s,\S）</li>
<li>  字符集合[] 匹配区间内任意字符</li>
<li>  [^a-z]匹配 ad-z 之间的</li>
<li>  +匹配一次或者多次</li>
<li>  *匹配 0 次或者多次</li>
<li>  ?匹配一次或者 0 次</li>
<li>  分组匹配 ()-分组 | -或者 ?:（https|http）:/{2}w{3}.(baidu|bilibili).(?:com|cn) ($1,$2,$3)分别代表不同的分组</li>
<li>  增加?: 可以使$1 不捕获分组 可以放在最前面全局生效，也可以单独使用</li>
<li>  捕获方法 RegExp.$1</li>
<li>  正向肯定预查 \d+(?=元) 表示肯定是元但是不匹配</li>
<li>  正向否定预查 \d(?!元|\d)）表示肯定不是元，不匹配</li>
<li>  反向肯定预查 （?&gt;=¥\d+）\d 表示肯定是 ¥，不匹配</li>
<li>  反向肯定预查 （?&gt;!¥\d+）\d 表示肯定不是 ¥，不匹配</li>
<li>  重复类 \d{4,8} 重复的最小 4 位,最长 8 位 {}</li>
<li>  正则对象 test() 返回一个布尔值，表示当前模式是否能匹配参数字符串</li>
<li>  正则对象 exec() 返回匹配的结果，如果发现匹配则返回一个数组，数组中的成员都是匹配成功的字符串，无则返回 null,返回的是类数组</li>
<li>  正则字符串 match() 对字符串进行正则匹配，返回匹配的结果，数组中的成员都是匹配成功的字符串，无则返回 null，返回数组</li>
<li>  exec 是正则的方法，而 match 是 string 的方法</li>
<li>  exec 与全局是否定义无关系，只匹配一个，而 match 则于全局相关联，当定义全局时，match 将匹配所有的，当定义为非全局，两者执行结果相同；</li>
<li>  如果 string 中有多个与正则匹配的值，那么第一个 exec 匹配 string 中匹配的第一个值，第二个相同的正则的 exec 将会选取第二个匹配的值</li>
<li>  search 返回第一个满足条件的匹配结果再字符串中的位置，如果没有返回 -1</li>
<li>  replace(/./g,’-‘) 可以替换匹配的值，接收两个参数第一个正则，第二个是替换的内容 g 全局替换</li>
</ul>
<h3 id="测试案例，规则不一定"><a href="#测试案例，规则不一定" class="headerlink" title="测试案例，规则不一定"></a>测试案例，规则不一定</h3><h3 id="验证用户账号（验证规则：字母，数字，下划线，字母开头，4-16-位）"><a href="#验证用户账号（验证规则：字母，数字，下划线，字母开头，4-16-位）" class="headerlink" title="验证用户账号（验证规则：字母，数字，下划线，字母开头，4-16 位）"></a>验证用户账号（验证规则：字母，数字，下划线，字母开头，4-16 位）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re =<span class="regexp">/^[a-zA-Z]\w&#123;3,15&#125; $/</span></span><br><span class="line">&lt;!-- 第一个是字母，后面<span class="number">3</span>位加起来<span class="number">4</span>位 --&gt;</span><br></pre></td></tr></table></figure>

<h3 id="验证手机号（11-位，以-1-开头，3578）"><a href="#验证手机号（11-位，以-1-开头，3578）" class="headerlink" title="验证手机号（11 位，以 1 开头，3578）"></a>验证手机号（11 位，以 1 开头，3578）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re =<span class="regexp">/^1[3|5|7|8]\d/</span>&#123;<span class="number">9</span>&#125;g$/g</span><br><span class="line"></span><br><span class="line">​<span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">### 匹配电话号码（区号+号码）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">​`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^0\d&#123;2,3&#125;-?\d&#123;7,8&#125;$/g</span></span><br><span class="line"></span><br><span class="line">​<span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">### 匹配身份证号（18位或者15位，15位全是数字，18位前17位是数字，最后一位可能是x或者X）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">​`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(x|X)$)/g</span></span><br><span class="line"></span><br><span class="line">​<span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">### 验证邮箱（第一部分@，第二部分.com|.cn|.net）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">​`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">var</span> re = <span class="regexp">/^[a-zA-Z.-_]+[@][a-zA-Z.-_]+\.(com|cn|net)\$/g</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="cktu3u7sp000j1aychlxo5op8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-TS" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/TS/" class="article-date">
  <time datetime="2020-11-29T05:47:17.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/TS/">TS</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="ts-提供的数据类型"><a href="#ts-提供的数据类型" class="headerlink" title="ts 提供的数据类型"></a>ts 提供的数据类型</h3><ul>
<li>  boolean</li>
<li>  number</li>
<li>  string</li>
<li>  array</li>
<li>  tuple(元祖类型)(元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同)</li>
<li>  enum（枚举类型）</li>
<li>  any（任意类型）(在编程阶段还不清楚类型的变量指定一个类型。)</li>
<li>  null,undefined (默认情况下 null 和 undefined 是所有类型的子类型)</li>
<li>  void (它表示没有任何类型)</li>
<li>  never (那些永不存在的值的类型)</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 元素类型后面接上 []，表示由此类型元素组成的一个数组：</span></span><br><span class="line"><span class="keyword">let</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// 数组泛型，Array&lt;元素类型&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line">x = [<span class="string">&quot;hello&quot;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&quot;hello&quot;</span>]; <span class="comment">// Error</span></span><br><span class="line"><span class="comment">//当访问一个越界的元素，会使用联合类型替代：(string | number)类型</span></span><br><span class="line">x[<span class="number">3</span>] = <span class="string">&quot;world&quot;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认情况下，从0开始为元素编号</span></span><br><span class="line"><span class="built_in">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green,</span><br><span class="line">    Blue,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">console</span>.log(colorName); <span class="comment">// 显示&#x27;Green&#x27;因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>

<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length; <span class="comment">//尖括号”语法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length; <span class="comment">//as语法</span></span><br></pre></td></tr></table></figure>

<h2 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h2><ul>
<li>块级作用域<ul>
<li>  （包含它们的块或 for 循环之外是不能访问的）</li>
<li>  拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 let 语句之前访问它们，幸运的是 TypeScript 可以告诉我们这些信息。</li>
</ul>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>  typeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">    label: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">size</span>: <span class="number">10</span>, <span class="attr">label</span>: <span class="string">&quot;Size 10 Object&quot;</span> &#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure>

<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><ul>
<li>  可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="keyword">let</span> newSquare = &#123; <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>, <span class="attr">area</span>: <span class="number">100</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (config.clor) &#123;</span><br><span class="line">        <span class="comment">// Error: Property &#x27;clor&#x27; does not exist on type &#x27;SquareConfig&#x27;</span></span><br><span class="line">        newSquare.color = config.clor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">        newSquare.area = config.width * config.width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">color</span>: <span class="string">&quot;black&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><ul>
<li>  一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly 来指定只读属性</li>
<li>  TypeScript 具有 ReadonlyArray<T>类型，它与 Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改</li>
<li>  最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// error!</span></span><br><span class="line">a = ro; <span class="comment">// error!</span></span><br><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[]; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h2 id="额外的属性检查-3-种方式"><a href="#额外的属性检查-3-种方式" class="headerlink" title="额外的属性检查(3 种方式)"></a>额外的属性检查(3 种方式)</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>; <span class="comment">//最佳的方式是够添加一个字符串索引签名,前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; area: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br><span class="line"><span class="comment">//绕开这些检查非常简单。 最简便的方法是使用类型断言：</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">opacity</span>: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br><span class="line"><span class="comment">//还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错。</span></span><br><span class="line"><span class="keyword">let</span> squareOptions = &#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(squareOptions);</span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><ul>
<li>  为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</li>
<li>  对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</li>
<li>  函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, <span class="attr">subString</span>: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc;</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = source.search(subString);</span><br><span class="line">    <span class="keyword">return</span> result &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><ul>
<li>  可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。</li>
<li>  TypeScript 支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。</li>
<li>  可以将索引签名设置为只读，这样就防止了给索引赋值</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray;</span><br><span class="line">myArray = [<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Fred&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!</span></span><br><span class="line"><span class="keyword">interface</span> NotOkay &#123;</span><br><span class="line">    [x: <span class="built_in">number</span>]: Animal;</span><br><span class="line">    [x: <span class="built_in">string</span>]: Dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rhino</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;Rhino&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = theName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">&quot;Goat&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino();</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line"></span><br><span class="line">animal = rhino;</span><br><span class="line">animal = employee; <span class="comment">// 错误: Animal 与 Employee 不兼容.</span></span><br></pre></td></tr></table></figure>

<h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><ul>
<li>  使用 any 类型会导致这个函数可以接收任何类型的 arg 参数，这样就丢失了一些信息：传入的类型与返回的类型应该是相同的。如果我们传入一个数字，我们只知道任何类型的值都有可能被返回。 因此，我们需要一种方法使返回值的类型与传入参数的类型是相同的。 这里，我们使用了 类型变量，它是一种特殊的变量，只用于表示类型而不是值。</li>
<li>  T (泛型变量)适用于多个类型</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length); <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//入符合约束类型的值，必须包含必须的属性</span></span><br><span class="line">loggingIdentity(&#123; <span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span> &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="范型约束"><a href="#范型约束" class="headerlink" title="范型约束"></a>范型约束</h2><p>-</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><ul>
<li>  使用枚举我们可以定义一些带名字的常量。</li>
<li>  使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript 支持数字的和基于字符串的枚举。</li>
<li>  数字枚举，字符串枚举，异构枚举（Heterogeneous enums）（混合使用数字和字符串-不建议使用）</li>
<li>  一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li>
<li>  一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li>
<li>  带括号的常量枚举表达式</li>
<li>  一元运算符 +, -, ~其中之一应用在了常量枚举表达式</li>
<li>  常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举- 表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。</li>
</ul>
<h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><ul>
<li><p>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p>
<ul>
<li>  任何字符串字面量（例如： “foo”， “bar”， “baz”）</li>
<li>  任何数字字面量（例如： 1, 100）</li>
<li>  应用了一元 -符号的数字字面量（例如： -1, -100）</li>
</ul>
</li>
<li><p>  数字枚举存在反向映射（ value -&gt; name）</p>
</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> ShapeKind &#123;</span><br><span class="line">    Circle,</span><br><span class="line">    Square,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: ShapeKind.Circle;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: ShapeKind.Square;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: Circle = &#123;</span><br><span class="line">    kind: ShapeKind.Square,</span><br><span class="line">    <span class="comment">//    ~~~~~~~~~~~~~~~~ Error!</span></span><br><span class="line">    radius: <span class="number">100</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> Enum &#123;</span><br><span class="line">    A,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Enum.A;</span><br><span class="line"><span class="keyword">let</span> nameOfA = Enum[a]; <span class="comment">// &quot;A&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a>const 枚举</h3><ul>
<li>  为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const 枚举。 常量枚举通过在枚举上使用 const 修饰符来定义。</li>
</ul>
<h3 id="外部枚举-用来描述已经存在的枚举类型的形状"><a href="#外部枚举-用来描述已经存在的枚举类型的形状" class="headerlink" title="外部枚举(用来描述已经存在的枚举类型的形状)"></a>外部枚举(用来描述已经存在的枚举类型的形状)</h3><ul>
<li>  外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="built_in">enum</span> Enum &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B,</span><br><span class="line">    C = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><ul>
<li><p>类装饰器</p>
<ul>
<li><p>类装饰器一般主要应用于类构造函数，可以监视、修改、替换类的定义，装饰器用来装饰类的时候。装饰器函数的第一个参数，就是所要装饰的目标类本身。</p>
</li>
<li><p>添加类装饰器后，构造函数会继承类装饰器的修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test()</span><br><span class="line">class Hello &#123;&#125;</span><br><span class="line">function Test(target) &#123;</span><br><span class="line">   target.a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">let o &#x3D; new Hello();</span><br><span class="line">console.log(o.a) &#x3D;&#x3D;&gt;1</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>属性装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Test()</span><br><span class="line">class Hello &#123;&#125;</span><br><span class="line"></span><br><span class="line">function Test(target) &#123;</span><br><span class="line">   target.prototype.a &#x3D; 1;</span><br><span class="line">   target.prototype.f &#x3D; function()&#123;</span><br><span class="line">       console.log(&quot;新增加方法&quot;)</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let o &#x3D; new Hello();</span><br><span class="line">o.f() &#x3D;&#x3D;&gt;&quot;新增加方法&quot;</span><br><span class="line">console.log(o.a) &#x3D;&#x3D;&gt;1</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法装饰器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import &#123;render&#125; from &#39;react-dom&#39;</span><br><span class="line">import &#123;connect&#125; from &#39;react-redux&#39;</span><br><span class="line">import &#123;bindActionCreators&#125; from &#39;redux&#39;</span><br><span class="line">import action from &#39;action.js&#39;</span><br><span class="line"></span><br><span class="line">class App extends React.Component&#123;</span><br><span class="line">  render()&#123;</span><br><span class="line">    return &lt;div&gt;hello&lt;&#x2F;div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">function mapStateToProps(state)&#123;</span><br><span class="line">  return state.main</span><br><span class="line">&#125;</span><br><span class="line">function mapDispatchToProps(dispatch)&#123;</span><br><span class="line">  return bindActionCreators(action,dispatch)</span><br><span class="line">&#125;</span><br><span class="line">export default connect(mapStateToProps,mapDispatchToProps)(App)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li>参数装饰器</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/TS/" data-id="cktu3u7sc000a1ayc2mez1z80" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/https-www-tslang-cn-docs-handbook-type-inference-html/" rel="tag">https://www.tslang.cn/docs/handbook/type-inference.html</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-数据结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2020-11-29T05:44:25.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>栈</li>
<li>队列</li>
<li>链表（每个元素由一个存储元素本身的节点和指向下一个元素的引用组成）<ul>
<li>优点<ul>
<li>1.内存空间不必是连续的</li>
<li>2.创建时不必确定大小</li>
<li>3.插入和删除数据时，时间复杂度 O(1),效率高</li>
</ul>
</li>
<li>缺点<ul>
<li>1.无论访问那个元素都需要从头找（无法跳过一个访问下一个）</li>
<li>2.无法通过下标直接访问元素，需要从头访问</li>
</ul>
</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cktu3u7sp000i1ayc1mvrbh3z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-WEBPACK" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/WEBPACK/" class="article-date">
  <time datetime="2020-11-29T05:42:27.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/WEBPACK/">WEBPACK</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="webpack核心概念"><a href="#webpack核心概念" class="headerlink" title="webpack核心概念"></a>webpack核心概念</h3><ul>
<li><ol>
<li>entry</li>
</ol>
<ul>
<li>入口起点,指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。</li>
</ul>
</li>
<li><ol start="2">
<li>outpot</li>
</ol>
<ul>
<li>output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。</li>
</ul>
</li>
<li><p>3.loader （使得js可以理解其他类型的文件）</p>
<ul>
<li>webpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。<br>环境变量。</li>
</ul>
</li>
<li><p>4.plugins （进行压缩）</p>
<ul>
<li>用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入</li>
</ul>
</li>
<li><p>5.mode</p>
<ul>
<li>通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
<p>总结:webpack启动后会从 entry 里配置的 module 开始递归解析 entry依赖的所有 module，每找到一个module，就会根据配置的 loader 去找出对应的解析规则，对 module 进行转换后，再解析出当前 module 依赖的 module。这些单位会以 entry 为单位进行分组，一个entery和其所有依赖的module被分到一个租（chunk）.最后webpack会把所有文件转换成一个文件输出。再整个流程中webpac会再恰当的时机执行plugins里的逻辑</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">&#x27;uglifyjs-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./app.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>), <span class="comment">//必须是绝对路径（path.join）</span></span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devserver: &#123;</span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    pubilcPath: <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules:[&#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">//再执行style</span></span><br><span class="line">        <span class="string">&#x27;css-loader&#x27;</span> <span class="comment">//先解析css 下面先加载</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> UglifyJSPlugin() <span class="comment">//压缩打包的体积</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数作用域-闭包-外部作用域访问内部作用域"><a href="#函数作用域-闭包-外部作用域访问内部作用域" class="headerlink" title="函数作用域(闭包:外部作用域访问内部作用域)"></a>函数作用域(闭包:外部作用域访问内部作用域)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> modul = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;susan&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tell: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我的名称&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">window</span></span>) </span>&#123; <span class="comment">//更加规范</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;susan&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tell: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;我的名称&#x27;</span> + <span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.modul = &#123;tell&#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>

<h3 id="模块化的有点"><a href="#模块化的有点" class="headerlink" title="模块化的有点"></a>模块化的有点</h3><ul>
<li>作用域的封装-(不会暴露到全局作用域中)）</li>
<li>重用性</li>
<li>解除耦合-(模块之间不会相互影响)</li>
</ul>
<h4 id="模块化演化史"><a href="#模块化演化史" class="headerlink" title="模块化演化史"></a>模块化演化史</h4><h3 id="AMD-异步模块定义"><a href="#AMD-异步模块定义" class="headerlink" title="AMD(异步模块定义)"></a>AMD(异步模块定义)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&#x27;getSum&#x27;</span>,[<span class="string">&#x27;math&#x27;</span>],<span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;sum:&#x27;</span> + math.sum(a,b))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数（当前模块的ID）,第二个参数(当前模块的依赖),第三个参数（可以是对象或者函数） (函数-返回定义的值)（对象-对象本身就是当前模块的导出）</li>
</ul>
<h3 id="COMMONJS-2009"><a href="#COMMONJS-2009" class="headerlink" title="COMMONJS(2009)"></a>COMMONJS(2009)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="built_in">require</span> 引入 --&gt;</span><br><span class="line"><span class="keyword">const</span> math = <span class="built_in">require</span>(<span class="string">&#x27;./math&#x27;</span>)</span><br><span class="line">&lt;!-- <span class="built_in">exports</span> 导出 --&gt;</span><br><span class="line"><span class="built_in">exports</span>.getSum = <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">    retrun a+ b</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES6-MODULE"><a href="#ES6-MODULE" class="headerlink" title="ES6 MODULE"></a>ES6 MODULE</h3><p>import math from ‘./math’<br>export function() sum(a,b) {<br> retrun a + b<br>}</p>
<h3 id="打包机制"><a href="#打包机制" class="headerlink" title="打包机制"></a>打包机制</h3><ul>
<li>1.判断这个模块是否被加载过,如果被加载过直接返回依赖</li>
<li>2.创建一个模块，把模块塞入installedModules对象中</li>
<li>3.改变模块的this,到__webpack_require__上</li>
<li>4.修改模块的加载状态</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(installedModules[moduleId]) &#123;</span><br><span class="line">    retrun installedModules[moduleId].export</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    i:moduleId,</span><br><span class="line">    l:<span class="literal">false</span>,</span><br><span class="line">    <span class="built_in">exports</span>:&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  modules[moduleId].call(</span><br><span class="line">    <span class="built_in">module</span>.exports,</span><br><span class="line">    <span class="built_in">module</span>,</span><br><span class="line">    <span class="built_in">module</span>.exports,</span><br><span class="line">    __webpack_require__</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="webpack的打包过程"><a href="#webpack的打包过程" class="headerlink" title="webpack的打包过程"></a>webpack的打包过程</h3><ul>
<li>1.从入口文件开始，分析整个应用的依赖树</li>
<li>2.将每个依赖模块，放到一个数组中等待调用</li>
<li>3.实现模块的加载方法，并把它放到模块执行的环境中去，确保模块间可以相互调用</li>
<li>4.把一个执行入口文件的逻辑放在一个函数表达式中，并立即执行这个函数</li>
</ul>
<h3 id="npm-包管理器"><a href="#npm-包管理器" class="headerlink" title="npm(包管理器)"></a>npm(包管理器)</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/WEBPACK/" data-id="cktu3u7si000d1ayc7kuxhvq9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ES6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/ES6/" class="article-date">
  <time datetime="2020-11-29T05:09:28.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/ES6/">ES6</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="LET-和-CONST"><a href="#LET-和-CONST" class="headerlink" title="LET 和 CONST"></a>LET 和 CONST</h2><ul>
<li>  let 声明指在代码块中有效 所以外部无法获取到 i,防止了变量泄漏</li>
<li>  区别（const 无法修改指的是指针无法修改，如果声明的是一个对象是可以修改它的属性，但是不可以修改它的指向）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>) &#123;&#125;<span class="comment">//每次循环都是一个新的变量，js引擎会记住上轮循环的值，从而计算这轮的值。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>) &#123;&#125;<span class="comment">//全局只有一个变量，每次循环都会修改，</span></span><br></pre></td></tr></table></figure>

<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><ul>
<li>  var–变量在声明前使用，undefined</li>
</ul>
<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><ul>
<li>  只要块级区域内存在 let 命令，他所声明的变量就绑定在这个区域，不受外部影响（在代码块内，使用 let 声明变量前，该变量都是不可用的）</li>
</ul>
<h3 id="不允许重复声明（看作用域）"><a href="#不允许重复声明（看作用域）" class="headerlink" title="不允许重复声明（看作用域）"></a>不允许重复声明（看作用域）</h3><ul>
<li>  一个作用域里面只能有一个变量</li>
</ul>
<h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ul>
<li>  他们的变量在 {}之间是相互独立存在的</li>
<li>  在块级作用域中可以声明函数</li>
</ul>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><ul>
<li><p>  1.对象的状态不受外界影响</p>
</li>
<li><p>  2.一旦状态改变就不会再变，任何时候都可以得到这个结果。</p>
</li>
<li><p>  缺点：无法取消一旦新建立刻执行，无法中途取消.如果不设置回调函数，promise 内部的错误不会反应到外部。当初与 pending 状态时，无法得知目前进展到那个阶段（刚刚开始还是即将完成）</p>
</li>
<li><p>  resolve 函数的作用 将对象的状态从 未完成变成已完成，将异步操作的结果作为参数传递出去</p>
</li>
<li><p>  reject 函数的作用 将对象的状态从 未完成变成已失败，将异步操作的错误作为参数传递出去</p>
</li>
<li><p>  then 方法用来指定成功和失败的回调函数，then 接受两个回调函数作为参数，第一个回调函数在状态变成 resolved 时调用，第二个回调在状态变成 rejected 时调用（可选）</p>
</li>
<li><p>  catch 方法是 then(null, rejection)的别名，用来指定发生错误时的回调函数,而且 catch 可以捕获之前所有 then 执行中的错误.</p>
</li>
<li><p>  var p = promise.all([p1,p2,p3]) 只有 p1,p2,p3 都成功,p 的状态才成功,有一个失败 p 就失败.</p>
</li>
<li><p>  var p = promise.race([p1,p2,p3]) 只要有一个的状态改变.就获取改变的那个状态.</p>
</li>
</ul>
<h3 id="iterator-和-for…of-循环"><a href="#iterator-和-for…of-循环" class="headerlink" title="iterator 和 for…of 循环"></a>iterator 和 for…of 循环</h3><ul>
<li>  为各种数据提供一个统一、简便的访问接口</li>
<li>  使数据的成员可以按照某种次序排列，</li>
<li>  供 for…of 消费</li>
<li>遍历过程如下<ul>
<li>  1.创建一个指针对象，指向当前数据结构的起始位置。本质就是一个指针对象</li>
<li>  2.第一次调用指针对象的 next 方法，指针对象指向第一个成员</li>
<li>  3.第二次调用指针对象的 next 方法，指针对象指向第二个成员</li>
<li>  4.不断的用指针对象的 next 方法，直到它指向数据结构的结束为止</li>
</ul>
</li>
</ul>
<h3 id="闭包原理"><a href="#闭包原理" class="headerlink" title="闭包原理"></a>闭包原理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;有鱼&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、闭包原理</p>
<ul>
<li>闭包的实现原理，其实是利用了作用域链的特性，我们都知道作用域链就是在当前执行环境下访问某个变量时，如果不存在就一直向外层寻找，最终寻找到最外层也就是全局作用域，这样就形成了一个链条。<br>  三、闭包作用</li>
<li>  作用 1：隐藏变量，避免全局污染</li>
<li>  作用 2：可以读取函数内部的变量</li>
<li>  同时闭包使用不当，优点就变成了缺点：</li>
<li>  缺点 1：导致变量不会被垃圾回收机制回收，造成内存消耗</li>
<li>  缺点 2：不恰当的使用闭包可能会造成内存泄漏的问题</li>
<li>JS 垃圾回收机制；<br>  JS 规定在一个函数作用域内，程序执行完以后变量就会被销毁，这样可节省内存；<br>  使用闭包时，按照作用域链的特点，闭包（函数）外面的变量不会被销毁，因为函数会一直被调用，所以一直存在，如果闭包使用过多会造成内存销毁。</li>
</ul>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><h3 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h3><h3 id="将对象的-key-变成字符串和不变有什么区别"><a href="#将对象的-key-变成字符串和不变有什么区别" class="headerlink" title="将对象的 key 变成字符串和不变有什么区别"></a>将对象的 key 变成字符串和不变有什么区别</h3><h3 id="接口传参方式总结"><a href="#接口传参方式总结" class="headerlink" title="接口传参方式总结"></a>接口传参方式总结</h3><h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><h3 id="this-上下文判断"><a href="#this-上下文判断" class="headerlink" title="this 上下文判断"></a>this 上下文判断</h3><blockquote>
<p>this 指向函数执行时的上下文对象，<br>以函数形式调用，永远指向 window<br>以方法形式调用，this 指向调用方法的对象</p>
</blockquote>
<ul>
<li>  规则 1：函数直接用圆括号运行，上下文是 window 对象。</li>
<li>  规则 2：对象打点调用函数，上下文是这个对象</li>
<li>  规则 3：数组（类数组对象）中枚举出函数，上下文是这个数组（类数组对象）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">0</span>](<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.length);</span><br><span class="line">    alert(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line">fun1(fun2, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>函数 fun2 作为参数传入函数 fun1 中，类数组对象中枚举出函数，然后运行上下文是这个类数组对象，fun2 函数里面的 this 是 fun1 的实际参数列表！，所以 this.length 的值为 5，arguments.length 为 2。</p>
</blockquote>
<ul>
<li>  规则 4：定时器调用函数，上下文是 window</li>
<li>  规则 5：被当作了事件处理函数，上下文是触发事件的 DOM 元素</li>
<li>  规则 6：用 new 调用函数，上下文是函数体内秘密创建的空白对象</li>
<li>  规则 7: 用 apply、call 执行上下文</li>
</ul>
<h3 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h3><ul>
<li>  super 这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。</li>
<li>  第一种情况，super 作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次 super 函数。</li>
</ul>
<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h3 id="事件的委派"><a href="#事件的委派" class="headerlink" title="事件的委派"></a>事件的委派</h3><ul>
<li>  在父级元素上绑定事件，通过事件的冒泡获取到点击事件，在通过对子元素增加 class 来 event.trage.class 过滤</li>
</ul>
<h3 id="事件的绑定"><a href="#事件的绑定" class="headerlink" title="事件的绑定"></a>事件的绑定</h3><ul>
<li>  attacheevent(IE8)</li>
<li>  addeventlistenr 为元素绑定响应事件（包含三个参数）（可以同时绑定多个事件）</li>
<li><ol>
<li>事件对名称 （click）</li>
</ol>
</li>
<li><ol start="2">
<li>回调函数，事件触发时被调用</li>
</ol>
</li>
<li><ol start="3">
<li>是否在捕获阶段触发，一般为 false</li>
</ol>
</li>
</ul>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ul>
<li>  reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</li>
<li>  function(total,currentValue, index,arr)</li>
<li>  total(必需)。初始值, 或者计算结束后的返回值。</li>
<li>  currentValue(必需)。当前元素</li>
<li>  currentIndex(可选)。当前元素的索引</li>
<li>  arr(可选)。当前元素所属的数组对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = nums.reduce(<span class="function">(<span class="params">total, item</span>) =&gt;</span> total + item, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>  累加器(acc)从初始值(initialValue)：0 开始的</li>
<li>  然后第一个 item 是 1，所以返回值是 1（0+1=1）</li>
<li>  1 在下次调用时成为累加器</li>
<li>  现在我们累加器是 1(acc)，item (数组的第二项)是 3</li>
<li>  返回值变为 4（1+3=4）</li>
<li>  4 在下次调用时成为累加器，调用时的下一项 item 是 6</li>
<li>  结果是 10（4+6=10），是我们的最终值，因为 6 是数组中的最后一项</li>
</ul>
<h2 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h2><h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><ul>
<li>  TypeScript 里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。）</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Named;</span><br><span class="line"><span class="comment">// OK, because of structural typing</span></span><br><span class="line">p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<h3 id="for…in-vs-for…of"><a href="#for…in-vs-for…of" class="headerlink" title="for…in vs for…of"></a>for…in vs for…of</h3><ul>
<li>  for..of 和 for..in 均可迭代一个列表；但是用于迭代的值却不同，for..in 迭代的是对象的 键 的列表，而 for..of 则迭代对象的键对应的值。</li>
<li>  另一个区别是 for..in 可以操作任何对象；它提供了查看对象属性的一种方法。 但是 for..of 关注于迭代对象的值。内置对象 Map 和 Set 已经实现了 Symbol.iterator 方法，让我们可以访问它们保存的值。</li>
</ul>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><blockquote>
<p><strong><code>instanceof</code></strong> <strong>运算符</strong>用于检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Object</span>;</span><br><span class="line">C.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>



<h4 id="instanceof和多个全局对象"><a href="#instanceof和多个全局对象" class="headerlink" title="instanceof和多个全局对象"></a>instanceof和多个全局对象</h4><blockquote>
<p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。</p>
</blockquote>
<p>ES5vsES6数组方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/ES6/" data-id="cktu3u7s300021ayc9xjj6l2s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Vue面试题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/29/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time datetime="2020-11-29T05:09:28.000Z" itemprop="datePublished">2020-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/11/29/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/">Vue面试题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="vue-生命周期"><a href="#vue-生命周期" class="headerlink" title="vue 生命周期"></a>vue 生命周期</h3><ul>
<li><p>基本概念</p>
</li>
<li><p>v-show 和 v-if 的区别</p>
</li>
<li><p>Vue 的单向数据流</p>
</li>
<li><p>异步请求适合在哪个生命周期调用？</p>
</li>
<li><p>Vue2.x 组件通信有哪些方式？</p>
<ul>
<li>  父子组件通信</li>
<li>  兄弟组件通信</li>
<li>  跨级组件通信</li>
</ul>
</li>
<li><p>什么是 SSR</p>
<ul>
<li>就是在服务端进行渲染生成html文件，浏览器显示生成html文件，</li>
</ul>
</li>
<li><p>Vue 路由</p>
</li>
<li><p>你有对 Vue 项目进行哪些优化？</p>
</li>
<li><p>Vue 中的 key 有什么作用？</p>
</li>
<li><p>虚拟 DOM 实现原理</p>
</li>
<li><p>虚拟 DOM 的优缺点</p>
</li>
<li><p>Proxy 与 Object.defineProperty 优劣对比</p>
</li>
<li><p>Vue 框架怎么实现对象和数组的监听？</p>
</li>
<li><p>Vue 是如何实现数据双向绑定的</p>
</li>
<li><p>v-model 的原理</p>
</li>
<li><p>组件中 data 为什么是一个函数？</p>
</li>
<li><p>谈谈你对 keep-alive</p>
</li>
<li><p>父组件可以监听到子组件的生命周期吗？</p>
</li>
<li><p>直接给一个数组项赋值，Vue 能检测到变化吗？</p>
</li>
<li><p>vue2.x 中如何监测数组变化</p>
</li>
<li><p>Vue2.x 和 Vue3.x 渲染器的 diff 算法分别说一下</p>
</li>
<li><p>Vue 模版编译原理</p>
</li>
<li><p>Computed 和 Watch</p>
</li>
<li><p>nextTick</p>
</li>
<li><p>vue 响应式原理</p>
</li>
<li><p>在使用计算属性的时，函数名和 data 数据源中的数据可以同名吗？</p>
</li>
<li><p>怎么解决 vue 打包后静态资源图片失效的问题</p>
</li>
<li><p>怎么解决 vue 动态设置 img 的 src 不生效的问题？</p>
<ul>
<li><p>动态添加src被当作静态资源处理了，没有进行编译。使用require来获取路径</p>
</li>
<li><p>可以在 vue.config.js 配置路径映射</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">	resolve: &#123;</span><br><span class="line">		alias: &#123;</span><br><span class="line">      <span class="comment">//path.resolve（）方法将路径或路径片段的序列解析为绝对路径</span></span><br><span class="line">      <span class="comment">//给定的路径序列从右到左处理，每个后续的 path 会被追加到前面，直到构建绝对路径。</span></span><br><span class="line">      <span class="comment">//如果在处理完所有给定的 path 片段之后，还没有生成绝对路径，则使用当前工作目录</span></span><br><span class="line">			<span class="comment">//注意：生成的路径被规范化，并删除尾部斜杠，零长度的 path 片段被忽略 ，没有传入 path 片段，则 path.resolve() 将返回当前工作目录的绝对路径     </span></span><br><span class="line">			utilties: path.resolve(__dirname,<span class="string">&#x27;src/utilties/&#x27;</span>) <span class="comment">//__dirname 获取绝对路径</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import Utilties form &#39;..&#x2F;..&#x2F;utiliies&#x2F;utiliy&#39;</span><br><span class="line">import Utilties form &#39;Utiliies&#x2F;utiliy&#39;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<ul>
<li>使用 vue 渲染大量数据时应该怎么优化？说下你的思路！</li>
</ul>
<h3 id="vue-router-相关问题"><a href="#vue-router-相关问题" class="headerlink" title="vue-router 相关问题"></a>vue-router 相关问题</h3><ul>
<li>  路由守卫生命周期</li>
<li>  说一下重定向和别名</li>
<li>  路由的切换是怎么做到的</li>
<li>  实现深拷贝的办法 以及实现思路</li>
<li>  vue 生命周期可以用来干嘛</li>
<li>  项目中的难点</li>
<li>  vue 和 angular 的使用区别</li>
<li>  vue 的使用优点</li>
<li>  长方形变圆形图片</li>
<li>  路由懒加载</li>
<li>vue 全家桶<ul>
<li>  vue-cli,vuex,vue-router,element-ui,Axios</li>
</ul>
</li>
<li>  mvvm 框架是什么</li>
<li>  vue-router 是什么，他有哪些组件</li>
<li>  active-class 是那个组件的属性</li>
<li>  路由模式（hash h5 history）</li>
</ul>
<blockquote>
<p>hash 有 #<br>history 无# （需要 server 支持-需要接口改）</p>
</blockquote>
<ul>
<li>  路由配置（动态路由，懒加载）</li>
</ul>
<h2 id="生命周期函数面试题"><a href="#生命周期函数面试题" class="headerlink" title="生命周期函数面试题"></a>生命周期函数面试题</h2><ul>
<li>  什么是 vue 生命周期</li>
</ul>
<blockquote>
<p>指 vue 实例对象从创建之初到销毁的过程，再这个过程中可以调用对应的钩子函数 来管理组件数据和渲染 DOM</p>
</blockquote>
<ul>
<li>  第一次加载 vue 会触发哪些钩子函数</li>
</ul>
<blockquote>
<p>beforeCreate, created, beforeMount, mounted</p>
</blockquote>
<ul>
<li><p>  VUE 生命周期详解 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/94601709">链接</a></p>
</li>
<li><p>  VUE 生命周期和 nextTick [链接](https</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/29/Vue%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cktu3u7sg000b1ayc8j82cv17" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/https-www-tslang-cn-docs-handbook-type-inference-html/" rel="tag">https://www.tslang.cn/docs/handbook/type-inference.html</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/https-www-tslang-cn-docs-handbook-type-inference-html/" style="font-size: 10px;">https://www.tslang.cn/docs/handbook/type-inference.html</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/22/vue3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/03/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/03/webscoket/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/07/29/axios/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/01/Vue-Router/">vue-router</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>