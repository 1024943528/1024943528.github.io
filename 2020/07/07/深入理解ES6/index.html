<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>深入理解ES6(尼古拉斯·泽卡斯) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第一章 VAR,LET,CONST块级作用域绑定 在函数作用域或全局作用域中通过关键字var声明的变量，无论实际上是在哪里声明的，都会被当成在当前作用域顶部声明的变量，这就是我们常说的提升（Hoisting）机制。  123456789101112function getValue(condition) &amp;#123;  &#x2F;&#x2F;1.var value   if(condition) &amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解ES6(尼古拉斯·泽卡斯)">
<meta property="og:url" content="http://example.com/2020/07/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 VAR,LET,CONST块级作用域绑定 在函数作用域或全局作用域中通过关键字var声明的变量，无论实际上是在哪里声明的，都会被当成在当前作用域顶部声明的变量，这就是我们常说的提升（Hoisting）机制。  123456789101112function getValue(condition) &amp;#123;  &#x2F;&#x2F;1.var value   if(condition) &amp;#123;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-07T05:09:28.000Z">
<meta property="article:modified_time" content="2021-07-20T06:24:14.506Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-深入理解ES6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/" class="article-date">
  <time datetime="2020-07-07T05:09:28.000Z" itemprop="datePublished">2020-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      深入理解ES6(尼古拉斯·泽卡斯)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="第一章-VAR-LET-CONST"><a href="#第一章-VAR-LET-CONST" class="headerlink" title="第一章 VAR,LET,CONST"></a>第一章 VAR,LET,CONST</h3><h4 id="块级作用域绑定"><a href="#块级作用域绑定" class="headerlink" title="块级作用域绑定"></a>块级作用域绑定</h4><blockquote>
<p>在函数作用域或全局作用域中通过关键字var声明的变量，无论实际上是在哪里声明的，都会被当成在当前作用域顶部声明的变量，这就是我们常说的提升（Hoisting）机制。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">condition</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.var value </span></span><br><span class="line">  <span class="keyword">if</span>(condition) &#123;</span><br><span class="line">    <span class="comment">//1.value = &#x27;blue&#x27;</span></span><br><span class="line">    <span class="comment">//2.var value = &#x27;blue&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value) <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(value)<span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="块级声明"><a href="#块级声明" class="headerlink" title="块级声明"></a>块级声明</h4><blockquote>
<p>块级声明用于声明在指定块的作用域之外无法访问的变量</p>
</blockquote>
<ul>
<li>块级作用域（亦被称为词法作用域）存在于：<ul>
<li>函数内部</li>
<li> 块中（字符{和}之间的区域） </li>
</ul>
</li>
</ul>
<blockquote>
<p>let 和 const 与 var 的另外一个区别是它们在全局作用域中的行为。当 var 被用于全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的 window 对象）的属性。这意味着用 var 很可能会无意中覆盖一个已经存在的全局变量，就像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在浏览器中, 如果名称一样就会覆盖已经存在的全局变量</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">RegExp</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp);</span><br><span class="line"><span class="keyword">var</span> ncz = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.ncz);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果你在全局作用域中使用let或const，会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。换句话说，用let或const不能覆盖全局变量，而只能遮蔽它</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只会遮蔽它，但全局变量依然存在，且没有被修改</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">RegExp</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.RegExp === <span class="built_in">RegExp</span>); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">const</span> ncz = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(ncz);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;ncz&quot;</span> <span class="keyword">in</span> <span class="built_in">window</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h4 id="第二章-字符串和正则表达式"><a href="#第二章-字符串和正则表达式" class="headerlink" title="第二章 字符串和正则表达式"></a>第二章 字符串和正则表达式</h4><blockquote>
<p>u修饰符实例:当一个正则表达式添加了u修饰符时，它就从编码单元操作模式切换为字符模式，如此一来正则表达式就不会视代理对为两个字符，从而完全按照预期正常运行。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">&#x27;𠮷&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(text.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/</span>.test(text)) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/^.$/u</span>.test(text)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h4 id="字符串中的子串识别"><a href="#字符串中的子串识别" class="headerlink" title="字符串中的子串识别"></a>字符串中的子串识别</h4><ul>
<li>indexOf 如果在字符串中检测到指定文本则返回下标，否则返回-1</li>
<li>Includes 如果在字符串中检测到指定文本则返回true，否则返回false</li>
<li>startsWith(str,iindex) 可以指定位置,不指定就检测第一位</li>
<li>endsWith(str,iindex) 可以指定位置,不指定就检测最后一位，有则从字符串长度减去这个索引值的位置开始匹配</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="第三章-函数"><a href="#第三章-函数" class="headerlink" title="第三章 函数"></a>第三章 函数</h4><blockquote>
<p>在非严格模式下，命名参数的变化会同步更新到arguments对象中，所以当first和second被赋予新值时，arguments[0]和arguments[1]相应地也就更新了，最终所有===全等比较的结果为true。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixArgs</span>(<span class="params">first, second = <span class="string">&#x27;b&#x27;</span></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>]) <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>])<span class="comment">// false,arguments[1]==undefined</span></span><br><span class="line">  first = <span class="string">&#x27;c&#x27;</span></span><br><span class="line">  second = <span class="string">&#x27;d&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(first === <span class="built_in">arguments</span>[<span class="number">0</span>])<span class="comment">// 非严格模式为true，严格模式为false</span></span><br><span class="line">  <span class="built_in">console</span>.log(second === <span class="built_in">arguments</span>[<span class="number">1</span>])<span class="comment">// 非严格模式为true，严格模式为false</span></span><br><span class="line">&#125;</span><br><span class="line">mixArgs(<span class="string">&#x27;a&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="默认参数的临时死区"><a href="#默认参数的临时死区" class="headerlink" title="默认参数的临时死区"></a>默认参数的临时死区</h4><blockquote>
<p>函数参数有自己的作用域和临时死区，其与函数体的作用域是各自独立的，也就是说参数的默认值不可访问函数体内声明的变量。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//let first = second</span></span><br><span class="line"><span class="comment">//let second = 1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">first = second, second</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> first + second</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>,)) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="literal">undefined</span>,<span class="number">1</span>)) <span class="comment">//抛出错误</span></span><br></pre></td></tr></table></figure>



<h4 id="处理无名参数"><a href="#处理无名参数" class="headerlink" title="处理无名参数"></a>处理无名参数</h4><blockquote>
<p>在函数的命名参数前添加三个点（…）就表明这是一个不定参数，该参数为一个数组，包含着自它之后传入的所有参数，通过这个数组名即可逐一访问里面的参数。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法错误：不定参数后面不能有其他命名参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pick</span>(<span class="params">object, ...key, last</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> result = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;len = keys.length;i&lt; len;i++) &#123;</span><br><span class="line">    result[keys[i]] = object[keys[i]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = &#123;</span><br><span class="line">	<span class="comment">//语法错误：不可以在setter中使用其他参数</span></span><br><span class="line">	<span class="keyword">set</span> <span class="title">name</span>(<span class="params">...value</span>) &#123;</span><br><span class="line">    <span class="comment">//执行一些逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="function构造函数"><a href="#function构造函数" class="headerlink" title="function构造函数"></a>function构造函数</h4><blockquote>
<p>这种构造函数接受字符串形式的参数，分别为函数的参数及函数体。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;return first + second&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ECMAScript 6增强了Function构造函数的功能，支持在创建函数时定义默认参数和不定参数。唯一需要做的是在参数名后添加一个等号及一个默认值</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second = first&#x27;</span>, <span class="string">&#x27;return first + second&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">1</span>)) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var pickFirst &#x3D; new Function(&#39;...args&#39;, &#39;return args[0]&#39;)</span><br></pre></td></tr></table></figure>



<h4 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a>name属性</h4><blockquote>
<p>doSomething()函数的name属性值为”doSomething”，对应着声明时的函数名称；匿名函数表达式doAnotherThing()的name属性值为”doAnotherThing”，对应着被赋值为该匿名函数的变量的名称</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dosomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> doanotherthing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dosomething.name) <span class="comment">// &#x27;dosomething&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(doanotherthing.name)<span class="comment">// &#x27;doanotherthing&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="name属性的特殊情况"><a href="#name属性的特殊情况" class="headerlink" title="name属性的特殊情况"></a>name属性的特殊情况</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span> <span class="title">doanotherthing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">firstName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;nicholas&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dosomething.name) <span class="comment">// &#x27;doanotherthing&#x27; 函数表达式的权重更高</span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName.name) <span class="comment">// &#x27;get firstName&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name) <span class="comment">// &#x27;sayName&#x27;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>通过bind()函数创建的函数，其名称将带有”bound”前缀；通过Function构造函数创建的函数，其名称将带有前缀”anonymous”，</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doSomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(doSomething.bind().name) <span class="comment">// &#x27;bound doSomething&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Function</span>().name) <span class="comment">// &#x27;anonymous&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="明确函数的多重用途"><a href="#明确函数的多重用途" class="headerlink" title="明确函数的多重用途"></a>明确函数的多重用途</h3><blockquote>
<p>JavaScript函数有两个不同的内部方法：[[Call]]和[[Construct]]。当通过new关键字调用函数时，执行的是[[Construct]]函数，它负责创建一个通常被称作实例的新对象，然后再执行函数体，将this绑定到实例上；如果不通过new关键字调用函数，则执行[[Call]]函数，从而直接执行代码中的函数体。具有[[Construct]]方法的函数被统称为构造函数。</p>
</blockquote>
<blockquote>
<p>切记，不是所有函数都有[[Construct]]方法，因此不是所有函数都可以通过new来调用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;nicolas&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> notAperson = Person(<span class="string">&#x27;nicolas&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// [&#x27;object object&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(notAperson) <span class="comment">//&#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>





<h4 id="es5中判断函数被调用的方法"><a href="#es5中判断函数被调用的方法" class="headerlink" title="es5中判断函数被调用的方法"></a>es5中判断函数被调用的方法</h4><blockquote>
<p>在ECMAScript 5中，如果想确定一个函数是否通过new关键字被调用（或者说，判断该函数是否作为构造函数被调用），最流行的方式是使用instanceof，对于函数本身，无法区分是通过Person.call()（或者是Person.apply()）还是new关键字调用得到的Person的实例</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">  <span class="comment">//if(typeof new.target !== &#x27;undefined&#x27;) &#123; // 是否通过关键字调用</span></span><br><span class="line">  <span class="comment">//if(typeof new.target == &#x27;Person&#x27;) &#123; //判断是否被某个特殊构造函数所调用</span></span><br><span class="line">		<span class="built_in">this</span>.name = name</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> error(<span class="string">&#x27;必须通过new关键字来调用person&#x27;</span>)</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;nicolas&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> notAperson = Person(<span class="string">&#x27;nicolas&#x27;</span>) <span class="comment">//失败</span></span><br><span class="line"><span class="keyword">var</span> notAperson = Person.call(person, <span class="string">&#x27;nicolas&#x27;</span>) <span class="comment">//有效</span></span><br></pre></td></tr></table></figure>



<h4 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h4><blockquote>
<p>为了解决判断函数是否通过new关键字调用的问题，ECMAScript 6引入了new.target这个元属性。元属性是指非对象的属性，其可以提供非对象目标的补充信息（例如new）。当调用函数的[[Construct]]方法时，new.target被赋值为new操作符的目标，通常是新创建对象实例，也就是函数体内this的构造函数；如果调用[[Call]]方法，则new.target的值为undefined。</p>
</blockquote>
<h4 id="块级函数"><a href="#块级函数" class="headerlink" title="块级函数"></a>块级函数</h4><blockquote>
<p>在定义函数的代码块内，块级函数会被提升至顶部，所以typeof doSomething的值为”function”，这也佐证了，即使你在函数定义的位置前调用它，还是能返回正确结果；但是一旦if语句代码块结束执行，doSomething()函数将不再存在。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething) <span class="comment">//&#x27;function&#x27;</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	doSomething()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> doSomething) <span class="comment">//&#x27;undefined&#x27;-非严格模式效可以获取，在该代码块中，块级函数会被提升至块的顶部</span></span><br></pre></td></tr></table></figure>



<h4 id="块级函数的使用场景"><a href="#块级函数的使用场景" class="headerlink" title="块级函数的使用场景"></a>块级函数的使用场景</h4><blockquote>
<p>块级函数与let函数表达式类似，一旦执行过程流出了代码块，函数定义立即被移除。二者的区别是，在该代码块中，块级函数会被提升至块的顶部，而用let定义的函数表达式不会被提升。</p>
</blockquote>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><ul>
<li>没有this、super、arguments和new.target绑定　箭头函数中的this、super、arguments及new.target这些值由外围最近一层非箭头函数决定。</li>
<li>不能通过new关键字调用　箭头函数没有[[Construct]]方法，所以不能被用作构造函数，如果通过new关键字调用箭头函数，程序会抛出错误</li>
<li>没有原型　由于不可以通过new关键字调用箭头函数，因而没有构建原型的需求，所以箭头函数不存在prototype这个属性。</li>
<li> 不可以改变this的绑定　函数内部的this值不可被改变，在函数的生命周期内始终保持一致。</li>
<li> 不支持arguments对象　箭头函数没有arguments绑定，所以你必须通过命名参数和不定参数这两种形式访问函数的参数。</li>
<li> 不支持重复的命名参数　无论在严格还是非严格模式下，箭头函数都不支持重复的命名参数；而在传统函数的规定中，只有在严格模式下才不能有重复的命名参数。</li>
</ul>
<h4 id="箭头函数语法"><a href="#箭头函数语法" class="headerlink" title="箭头函数语法"></a>箭头函数语法</h4><blockquote>
<p>当箭头函数只有一个参数时，可以直接写参数名，箭头紧随其后，箭头右侧的表达式被求值后便立即返回。即使没有显式的返回语句，这个箭头函数也可以返回传入的第一个参数，不需要更多的语法铺垫</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reflect = <span class="function"><span class="params">value</span> =&gt;</span> value</span><br><span class="line"><span class="comment">// 实际上相当于</span></span><br><span class="line"><span class="keyword">let</span> reflect = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2</span><br><span class="line"><span class="comment">// 实际上相当于,arguments对象不可用以外,某种程度上你都可以将花括号里的代码视作传统的函数体定义。</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果想在箭头函数外返回一个对象字面量，则需要将该字面量包裹在小括号里。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123;</span><br><span class="line">  id:id,</span><br><span class="line">  name: <span class="string">&#x27;temp&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 实际上相当于</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="keyword">function</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id:id,</span><br><span class="line">	  name: <span class="string">&#x27;temp&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="创建立即执行函数表达式"><a href="#创建立即执行函数表达式" class="headerlink" title="创建立即执行函数表达式"></a>创建立即执行函数表达式</h4><blockquote>
<p>JavaScript函数的一个流行的使用方式是创建立即执行函数表达式（IIFE），你可以定义一个匿名函数并立即调用，自始至终不保存对该函数的引用。当你想创建一个与其他程序隔离的作用域时，这种模式非常方便。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">&#x27;nicolas&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.getName) <span class="comment">//&#x27;nicolas&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>将箭头函数包裹在小括号里，就可以用它实现相同的功能</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let person &#x3D; ((name) &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    getName: function() &#123;</span><br><span class="line">      return name</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(&#39;nicolas&#39;)</span><br><span class="line">console.log(person.getName) &#x2F;&#x2F;&#39;nicolas&#39;</span><br></pre></td></tr></table></figure>



<h4 id="箭头函数中的this绑定"><a href="#箭头函数中的this绑定" class="headerlink" title="箭头函数中的this绑定"></a>箭头函数中的this绑定</h4><blockquote>
<p>箭头函数中没有this绑定，必须通过查找作用域链来决定其值。如果箭头函数被非箭头函数包含，则this绑定的是最近一层非箭头函数的this；否则，this的值会被设置为undefined。</p>
</blockquote>
<blockquote>
<p>以在箭头函数上调用call()、apply()及bind()方法，但与其他函数不同的是，箭头函数的this值不会受这些方法的影响</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let pageHandler &#x3D; &#123;</span><br><span class="line">	id: &#39;123&#39;,</span><br><span class="line">	init: function() &#123;</span><br><span class="line">		doucment.addEventListener(&#39;click&#39;,</span><br><span class="line">			event &#x3D;&gt; this.doSomething(event.type), false)</span><br><span class="line">	&#125;,</span><br><span class="line">	doSomething: function(type) &#123;</span><br><span class="line">		console.log(&#39;handling&#39; + type + &#39;for&#39; + this.id)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><blockquote>
<p>ECMAScript 6关于函数最有趣的变化可能是尾调用系统的引擎优化。尾调用指的是函数作为另一个函数的最后一条语句被调用</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingElse() <span class="comment">//尾调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="es6中的尾调用优化"><a href="#es6中的尾调用优化" class="headerlink" title="es6中的尾调用优化"></a>es6中的尾调用优化</h4><blockquote>
<p>ECMAScript 6缩减了严格模式下尾调用栈的大小（非严格模式下不受影响），如果满足以下条件，尾调用不再创建新的栈帧，而是清除并重用当前栈帧：</p>
</blockquote>
<ul>
<li> 尾调用不访问当前栈帧的变量（也就是说函数不是一个闭包）。</li>
<li> 在函数内部，尾调用是最后一条语句。</li>
<li> 尾调用的结果作为函数值返回。</li>
</ul>
<h4 id="如何利用尾调用优化"><a href="#如何利用尾调用优化" class="headerlink" title="如何利用尾调用优化"></a>如何利用尾调用优化</h4><blockquote>
<p>递归函数是其最主要的应用场景，此时尾调用优化的效果最显著</p>
</blockquote>
<blockquote>
<p>由于在递归调用前执行了乘法操作，因而当前版本的阶乘函数无法被引擎优化。如果n是一个非常大的数，则调用栈的尺寸就会不断增长并存在最终导致栈溢出的潜在风险。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n-<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>优化这个函数，首先要确保乘法不会在函数调用后执行，你可以通过默认参数来将乘法操作移出return语句，结果函数可以携带着临时结果进入到下一个迭代中。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, p =<span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(n &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> * p</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">let</span> result = n * p</span><br><span class="line">    <span class="keyword">return</span>  factorial(n-<span class="number">1</span>, result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象类别"><a href="#对象类别" class="headerlink" title="对象类别"></a>对象类别</h4><blockquote>
<p>在浏览器这样的执行环境中，对象没有统一的标准，在标准中又使用不同的术语描述对象，ECMAScript 6规范清晰定义了每一个类别的对象。总而言之，理解这些术语对理解这门语言来说非常重要，对象的类别如下：</p>
</blockquote>
<ul>
<li>普通（Ordinary）对象　具有JavaScript对象所有的默认内部行为。</li>
<li> 特异（Exotic）对象　具有某些与默认行为不符的内部行为。</li>
<li> 标准（Standard）对象　ECMAScript 6规范中定义的对象，例如，Array、Date等。标准对象既可以是普通对象，也可以是特异对象。</li>
<li> 内建对象　脚本开始执行时存在于JavaScript执行环境中的对象，所有标准对象都是内建对象。</li>
</ul>
<blockquote>
<p>在ECMAScript 6中，通过使用属性初始化的简写语法，可以消除这种属性名称与局部变量之间的重复书写。当一个对象的属性与本地变量同名时，不必再写冒号和值，简单地只写属性名即可。</p>
</blockquote>
<blockquote>
<p>当对象字面量里只有一个属性的名称时，JavaScript引擎会在可访问作用域中查找其同名变量；如果找到，则该变量的值被赋给对象字面量里的同名属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age</span>) </span>&#123;</span><br><span class="line">  retrun &#123;</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h4><blockquote>
<p>在ECMAScript 5及早期版本的对象实例中，如果想要通过计算得到属性名，就需要用方括号代替点记法。有些包括某些字符的字符串字面量作为标识符会出错，其和变量放在方括号中都是被允许的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;</span><br><span class="line">  	lastname = <span class="string">&#x27;last name&#x27;</span></span><br><span class="line">person[<span class="string">&quot;first name&quot;</span>] = <span class="string">&#x27;nicolas&#x27;</span> <span class="comment">//存在空格，就使用字符串</span></span><br><span class="line">person[lastname] = <span class="string">&#x27;zakas&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&quot;first name&quot;</span>]) </span><br><span class="line"><span class="built_in">console</span>.log(person[lastname])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>变量lastName被赋值为字符串”last name”，引用的两个属性名称中都含有空格，因而不可使用点记法引用这些属性，却可以使用方括号，因为它支持通过任何字符串值作为名称访问属性的值。</p>
</blockquote>
<blockquote>
<p>而在ECMAScript 6中，可在对象字面量中使用可计算属性名称，其语法与引用对象实例的可计算属性名称相同，也是使用方括号</p>
<p>在对象字面量中使用方括号表示的该属性名称是可计算的，它的内容将被求值并被最终转化为一个字符串，因而同样可以使用表达式作为属性的可计算名称</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastname = <span class="string">&#x27;last name&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="string">&quot;first name&quot;</span>: <span class="string">&#x27;nicolas&#x27;</span>,</span><br><span class="line">	[lastname]: <span class="string">&#x27;zakas&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&quot;first name&quot;</span>]) <span class="comment">//nicolas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[lastname]) <span class="comment">// zakas</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suffix = <span class="string">&#x27; name&#x27;</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	[<span class="string">&quot;first&quot;</span> + suffix]: <span class="string">&#x27;nicolas&#x27;</span>,</span><br><span class="line">	[<span class="string">&quot;last&quot;</span> + suffix]: <span class="string">&#x27;zakas&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&quot;first name&quot;</span>]) <span class="comment">//nicolas</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;last name&#x27;</span>]) <span class="comment">// zakas</span></span><br></pre></td></tr></table></figure>



<h4 id="object-is-方法"><a href="#object-is-方法" class="headerlink" title="object.is()方法"></a>object.is()方法</h4><blockquote>
<p>对于Object.is()方法来说，其运行结果在大部分情况中与===运算符相同，唯一的区别在于+0和-0被识别为不相等并且NaN与NaN等价。但是你大可不必抛弃等号运算符，是否选择用Object.is()方法而不是==或===取决于那些特殊情况如何影响代码。</p>
</blockquote>
<h4 id="object-assign-方法"><a href="#object-assign-方法" class="headerlink" title="object.assign()方法"></a>object.assign()方法</h4><blockquote>
<p>混合（Mixin）是JavaScript中实现对象组合最流行的一种模式。在一个mixin方法中，一个对象接收来自另一个对象的属性和方法，</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">receiver, supplier</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">Object</span>.keys(supplier).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">    	receiver[key] = supplier[key]</span><br><span class="line">   &#125;)</span><br><span class="line">  <span class="keyword">return</span> receiver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种混合模式非常流行，因而ECMAScript 6添加了Object.assign()方法来实现相同的功能，这个方法接受一个接收对象和任意数量的源对象，最终返回接收对象。mixin()方法使用赋值操作符（assignment operator）=来复制相关属性，却不能复制访问器属性到接收对象中，因此最终添加的方法弃用mixin而改用assign作为方法名。</p>
</blockquote>
<blockquote>
<p>Object.assign()方法可以接受任意数量的源对象，并按指定的顺序将属性复制到接收对象中。所以如果多个源对象具有同名属性，则排位靠后的源对象会覆盖排位靠前的，</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receiver = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(receiver, </span><br><span class="line">	&#123;</span><br><span class="line">  	type: <span class="string">&#x27;js&#x27;</span>,</span><br><span class="line">  	name: <span class="string">&#x27;fiel.js&#x27;</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  	type: <span class="string">&#x27;css&#x27;</span></span><br><span class="line">	&#125;            </span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(receiver.type) <span class="comment">//&#x27;css&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(receiver.name) <span class="comment">//&#x27;file.js&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="访问器属性-https-blog-csdn-net-lxiaopfeng-article-details-79811685"><a href="#访问器属性-https-blog-csdn-net-lxiaopfeng-article-details-79811685" class="headerlink" title="访问器属性[https://blog.csdn.net/lxiaopfeng/article/details/79811685]"></a>访问器属性[<a target="_blank" rel="noopener" href="https://blog.csdn.net/lxiaopfeng/article/details/79811685]">https://blog.csdn.net/lxiaopfeng/article/details/79811685]</a></h4><blockquote>
<p>访问器属性不包含数据值，它们包含一对getter和setter函数，通过定义访问器属性，可以实现设置一个属性的值会导致其它属性发生变化。(csdn)</p>
</blockquote>
<blockquote>
<p>请记住，Object.assign()方法不能将提供者的访问器属性复制到接收对象中。由于Object.assign()方法执行了赋值操作，因此提供者的访问器属性最终会转变为接收对象中的一个数据属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var receiver &#x3D; &#123;&#125;</span><br><span class="line">Object.assign(receiver, </span><br><span class="line">	&#123;</span><br><span class="line">  	type: &#39;js&#39;,</span><br><span class="line">  	name: &#39;fiel.js&#39;,</span><br><span class="line">	&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  	type: &#39;css&#39;</span><br><span class="line">	&#125;            </span><br><span class="line">)</span><br><span class="line">console.log(receiver.type) &#x2F;&#x2F;&#39;css&#39;</span><br><span class="line">console.log(receiver.name) &#x2F;&#x2F;&#39;file.js&#39;</span><br></pre></td></tr></table></figure>



<h4 id="自有属性枚举顺序"><a href="#自有属性枚举顺序" class="headerlink" title="自有属性枚举顺序"></a>自有属性枚举顺序</h4><ul>
<li>1.所有数字键按升序排序。</li>
<li>2.所有字符串键按照它们被加入对象的顺序排序。</li>
<li>3.所有symbol键，按照它们被加入对象的顺序排序</li>
</ul>
<blockquote>
<p>对于for-in循环，由于并非所有厂商都遵循相同的实现方式，因此仍未指定一个明确的枚举顺序；而Object.keys()方法和JSON.stringify()方法都指明与for-in使用相同的枚举顺序，因此它们的枚举顺序目前也不明晰。</p>
</blockquote>
<blockquote>
<p>正常情况下，无论是通过构造函数还是Object.create()方法创建对象，其原型是在对象被创建时指定的。对象原型在实例化之前保持不变，直到ECMAScript 5都是javaScript编程最重要的设定之一，虽然在ECMAScript 5中添加了Object.getPrototypeOf()方法来返回任意指定对象的原型，但仍缺少对象在实例化后改变原型的标准方法。</p>
</blockquote>
<blockquote>
<p>在ECMAScript 6中添加了Object.setPrototypeOf()方法来改变这一现状，通过这个方法可以改变任意指定对象的原型，它接受两个参数：被改变原型的对象及替代第一个参数原型的对象。</p>
</blockquote>
<blockquote>
<p>对象原型的真实值被储存在内部专用属性[[Prototype]]中，调用Object.getPrototypeOf()方法返回储存在其中的值，调用Object.setPrototypeOf()方法改变其中的值。然而，这不是操作[[Prototype]]值的唯一方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="function"><span class="title">getGreeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">	<span class="function"><span class="title">getGreeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;woof&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//person 已person为原型</span></span><br><span class="line"><span class="keyword">let</span> firend = Obecct.create(person)</span><br><span class="line"><span class="built_in">console</span>.log(firend.getGreeting()) <span class="comment">//&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(firend) === dog) <span class="comment">//true</span></span><br><span class="line"><span class="comment">//将原型设置为dog</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(firend, dog) <span class="comment">//</span></span><br><span class="line"><span class="built_in">console</span>.log(firend.getGreeting()) <span class="comment">// woof</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(firend) === dog) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<h4 id="简化原型访问的super引用"><a href="#简化原型访问的super引用" class="headerlink" title="简化原型访问的super引用"></a>简化原型访问的super引用</h4><blockquote>
<p>如果你想重写对象实例的方法，又需要调用与它同名的原型方法，则在ECMAScript 5中可以这样实现</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">	<span class="function"><span class="title">getGreeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dog = &#123;</span><br><span class="line">	<span class="function"><span class="title">getGreeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;woof&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> firend = &#123;</span><br><span class="line">	<span class="function"><span class="title">getGreeting</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return Object.getPrototyeOf(this).getGreeting.call(this) + &#x27;,hi&#x27;</span></span><br><span class="line">    <span class="comment">// return super.getGreeting() + &#x27;hi&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(firend, person) </span><br><span class="line"><span class="built_in">console</span>.log(firend.getGreeting()) <span class="comment">//hell0,hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeof((firend) === person)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(firend, dof) </span><br><span class="line"><span class="built_in">console</span>.log(firend.getGreeting()) <span class="comment">//woof,hi</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeof((firend) === dog)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>要准确记得如何使用Object.getPrototypeOf()方法和.call(this)方法来调用原型上的方法实在有些复杂，所以ECMAScript 6引入了super关键字。简单来说，Super引用相当于指向对象原型的指针，实际上也就是Object.getPrototypeOf(this)的值。</p>
</blockquote>
<blockquote>
<p> Super引用不是动态变化的，它总是指向正确的对象，在这个示例中，无论有多少其他方法继承了getGreeting方法，super.getGreeting()始终指向person.get-Greeting()方法。</p>
</blockquote>
<h4 id="正式的方法定义"><a href="#正式的方法定义" class="headerlink" title="正式的方法定义"></a>正式的方法定义</h4><blockquote>
<p>在ECMAScript 6以前从未正式定义“方法”的概念，方法仅仅是一个具有功能而非数据的对象属性。而在ECMAScript 6中正式将方法定义为一个函数，它会有一个内部的[[HomeObject]]属性来容纳这个方法从属的对象。</p>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>ECMAScript 6在对象字面量的基础上做出了以下几个变更：简化属性定义语法，使将当前作用域中的同名变量赋值给对象的语法变得更加简洁；添加可计算属性名特性，允许为对象指定非字面量属性名称；添加对象方法的简写语法，在对象字面量中定义方法时可以省略冒号和function关键字；ECMAScript 6弱化了严格模式下对象字面量重复属性名称的校验，即使在同一个对象字面量中定义两个同名属性也不会抛出错误。</p>
<p>Object.assign()方法可以一次性更改对象中的多个属性，如果使用混入（Mixin）模式这将非常有用；Object.is()方法对于所有值进行严格等价判断，当将其用于处理特殊JavaScript值问题时比===操作符更加安全。</p>
<p>在ECMAScript 6中同样清晰定义了自有属性的枚举顺序：当枚举属性时，数值键在先，字符串键在后；数值键总是按照升序排列，字符串键按照插入的顺序排列。</p>
<p>通过ECMAScript 6的Object.setPrototypeOf()方法，我们可以在对象被创建后修改它的原型。</p>
<p>最后，可以使用super关键字调用对象原型上的方法，此时的this绑定会被自动设置为当前作用域的this值.</p>
</blockquote>
<h4 id="解构赋值（使数据访问更加便捷）"><a href="#解构赋值（使数据访问更加便捷）" class="headerlink" title="解构赋值（使数据访问更加便捷）"></a>解构赋值（使数据访问更加便捷）</h4><blockquote>
<p>请注意，一定要用一对小括号包裹解构赋值语句，JavaScript引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程。</p>
<p>调用outputInfo()函数时传入了一个解构表达式，由于JavaScript表达式的值为右侧的值，因而此处传入的参数等同于node，且变量type和name被重新赋值，最终将node传入outputInfo()函数。</p>
<p>使用解构赋值表达式时，如果指定的局部变量名称在对象中不存在，那么这个局部变量会被赋值为undefined，</p>
<p>当指定的属性不存在时，可以随意定义一个默认值，在属性名称后添加一个等号</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">	type: <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">	name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">	type: <span class="string">&#x27;mouse&#x27;</span>,</span><br><span class="line">	name: <span class="string">&#x27;jerry&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputInfo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value === node) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">outputInfo(&#123;type, name&#125; = node)</span><br><span class="line">(&#123;type, name, value = <span class="literal">true</span>&#125; = node)</span><br></pre></td></tr></table></figure>



<h4 id="为非同名局部变量赋值"><a href="#为非同名局部变量赋值" class="headerlink" title="为非同名局部变量赋值"></a>为非同名局部变量赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">	type: <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">	name: <span class="string">&#x27;tom&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">type</span>: retype,<span class="attr">name</span>: localname == <span class="string">&#x27;bar&#x27;</span>&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(retype) <span class="comment">//cat</span></span><br><span class="line"><span class="built_in">console</span>.log(localname) <span class="comment">//bar</span></span><br></pre></td></tr></table></figure>



<h4 id="嵌套对象结构"><a href="#嵌套对象结构" class="headerlink" title="嵌套对象结构"></a>嵌套对象结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">	type: <span class="string">&#x27;cat&#x27;</span>,</span><br><span class="line">	name: <span class="string">&#x27;tom&#x27;</span>,</span><br><span class="line">  loc: &#123;</span><br><span class="line">    start: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;start&#125;&#125; = node</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;<span class="attr">start</span>: localstart&#125;&#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(start.line) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(start.column) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(localstart.start) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(localstart.column) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未声明任何变量</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">loc</span>: &#123;&#125;&#125;= node</span><br></pre></td></tr></table></figure>



<blockquote>
<p>在使用嵌套解构功能时请注意，你很可能无意中创建了一个无效表达式。内空花括号在对象解构的语法中是合法的，然而这条语句却什么都不会做：在这条语句中，由于右侧只有一对花括号，因而其不会声明任何绑定，loc不是即将创建的绑定，它代表了在对象中检索属性的位置。在上述示例中，更好的做法是使用=定义一个默认值。这个语法在将来有可能被废弃，但现在，你只需要警示自己不写类似的代码。</p>
</blockquote>
<h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><blockquote>
<p>在数组解构语法中，我们通过值在数组中的位置进行选取，且可以将其存储在任意变量中，未显式声明的元素都会直接被忽略。切记，在这个过程中，数组本身不会发生任何变化。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> [first,second] = colors</span><br><span class="line"><span class="keyword">let</span> [first,second =<span class="string">&#x27;green&#x27;</span>] = colors</span><br><span class="line"><span class="keyword">let</span> [,,third] = colors</span><br><span class="line"><span class="keyword">let</span> [a, b] =[b, a]</span><br></pre></td></tr></table></figure>

<h4 id="嵌套数组解构"><a href="#嵌套数组解构" class="headerlink" title="嵌套数组解构"></a>嵌套数组解构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, [<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>], <span class="string">&#x27;yellow&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> [first,[second]] = colors</span><br><span class="line"><span class="keyword">let</span> [first,...second] = colors <span class="comment">//sencond获取的是数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [...cloneColors] = colors</span><br></pre></td></tr></table></figure>

<h4 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">	loc: &#123;start&#125;,</span><br><span class="line">	range: [startIndex]</span><br><span class="line">&#125; = node</span><br></pre></td></tr></table></figure>



<h4 id="解构参数"><a href="#解构参数" class="headerlink" title="解构参数"></a>解构参数</h4><blockquote>
<p>当定义一个接受大量可选参数的JavaScript函数时，我们通常会创建一个可选对象，将额外的参数定义为这个对象的属性：</p>
<p>如果解构赋值表达式的右值为null或undefined，则程序会报错，同理，若调用setCookie()函数时不传入第3个参数，也会导致程序抛出错误。</p>
<p>但如果希望将解构参数定义为可选的，那么就必须为其提供默认值来解决这个问题</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,&#123;secure,path,domain,expires&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">setCookie(<span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;js&#x27;</span>,&#123;</span><br><span class="line">	secure: <span class="literal">true</span>,</span><br><span class="line">	expires: <span class="number">6000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这段代码中，默认值已经被放到setCookieDefaults对象中，除了作为默认参数值外，在解构参数中可以直接使用这个对象来为每一个绑定设置默认参数。使用解构参数后，不得不面对处理默认参数的复杂逻辑，但它也有好的一面，如果要改变默认值，可以立即在setCookieDefaults中修改，改变的数据将自动同步到所有出现过的地方。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setCookieDefaults = &#123;</span><br><span class="line">	secure: <span class="literal">false</span>,</span><br><span class="line">	path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">	domain: <span class="string">&#x27;example.com&#x27;</span>,</span><br><span class="line">	expires: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.now() + <span class="number">36000000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">  secure = setCookieDefaults.secure,</span></span></span><br><span class="line"><span class="function"><span class="params">  path = setCookieDefaults.path,</span></span></span><br><span class="line"><span class="function"><span class="params">  domain = setCookieDefaults.domain,</span></span></span><br><span class="line"><span class="function"><span class="params">  expires = setCookieDefaults.expires&#125; = setCookieDefaults</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>在对象和数组解构中，都可以为值为undefined的对象属性或数组元素设置默认值，且赋值表达式右值不可为null或undefind，否则程序会抛出错误。也可以无限深入到对象和数组解构嵌套的数据解构中。</p>
<p>可以使用var、let或const来解构声明变量，但按照语法规定必须要指定相应的初始化程序。可以用解构赋值代替其他赋值语句，将对象属性和已有的变量解构成更小的数据。</p>
<p>当定义函数参数时，用解构参数代替”options”对象可以将你真正感兴趣的数据与其他命名参数列在一起，使其更可读。解构参数可以是数组模式、对象模式或混合模式，也可以使用解构语法的其他功能。</p>
</blockquote>
<h4 id="symbol和symbol属性"><a href="#symbol和symbol属性" class="headerlink" title="symbol和symbol属性"></a>symbol和symbol属性</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> firstName = <span class="built_in">Symbol</span>(<span class="string">&#x27;first name&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line">person[firstName] = <span class="string">&#x27;nicolas&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;first name&#x27;</span> <span class="keyword">in</span> person) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(person[firstName]) <span class="comment">// &#x27;nicolas&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(firstname) <span class="comment">// &#x27;Symbol(&#x27;first name&#x27;)&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> firstName) <span class="comment">//&#x27;symbol&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于Symbol是原始值，因此调用new Symbol()会导致程序抛出错误。也可以执行new Object（你的Symbol）创建一个Symbol的实例，但目前尚不清楚这个功能何时可以使用。</p>
</blockquote>
<blockquote>
<p>Symbol函数接受一个可选参数，其可以让你添加一段文本描述即将创建的Symbol，这段描述不可用于属性访问，但是建议你在每次创建Symbol时都添加这样一段描述，以便于阅读代码和调试Symbol程序。</p>
</blockquote>
<h4 id="symbol共享体系"><a href="#symbol共享体系" class="headerlink" title="symbol共享体系"></a>symbol共享体系</h4><blockquote>
<p>如果想创建一个可共享的Symbol，要使用Symbol.for()方法。它只接受一个参数，也就是即将创建的Symbol的字符串标识符，这个参数同样也被用作Symbol的描述，</p>
</blockquote>
<blockquote>
<p>Symbol.for()方法首先在全局Symbol注册表中搜索键为”uid”的Symbol是否存在，如果存在，直接返回已有的Symbol；否则，创建一个新的Symbol，并使用这个键在Symbol全局注册表中注册，随即返回新创建的Symbol。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;uid&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> object = &#123;&#125;</span><br><span class="line">object[uid] = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(object[uid]) <span class="comment">//&#x27;12345&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(uid) <span class="comment">//&#x27;Symbol(&#x27;uid&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="symbol与强制类型转换"><a href="#symbol与强制类型转换" class="headerlink" title="symbol与强制类型转换"></a>symbol与强制类型转换</h4><blockquote>
<p>自动转型是JavaScript中的一个重要语言特性，利用这个特性能够在特定场景下将某个数据强制转换为其他类型。然而，其他类型没有与Symbol逻辑等价的值，因而Symbol使用起来不是很灵活，尤其是不能将Symbol强制转换为字符串和数字类型，否则如果不小心将其作为对象属性，最终会导致不一样的执行结果。</p>
<p>String()函数调用了uid.toString()方法，返回字符串类型的Symbol描述里的内容。但是，如果你尝试将Symbol与一个字符串拼接，会导致程序抛出错误</p>
<p>同样，也不能将Symbol强制转换为数字类型。将Symbol与每一个数学运算符混合使用都会导致程序抛出错误，</p>
<p>（逻辑操作符除外，因为Symbol与JavaScript中的非空值类似，其等价布尔值为true）</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;uid&#x27;</span>)</span><br><span class="line">		desc = uid + <span class="string">&#x27;&#x27;</span> <span class="comment">//报错</span></span><br><span class="line">		desc = <span class="built_in">String</span>(uid)</span><br><span class="line">		<span class="built_in">console</span>.log(desc) <span class="comment">//&#x27;Symbol(&#x27;uid&#x27;)&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="symbol属性检索"><a href="#symbol属性检索" class="headerlink" title="symbol属性检索"></a>symbol属性检索</h4><blockquote>
<p>Object.keys()方法和Object.getOwnPropertyNames()方法可以检索对象中所有的属性名：前一个方法返回所有可枚举的属性名；后一个方法不考虑属性的可枚举性一律返回。</p>
<p>然而为了保持ECMAScript 5函数的原有功能，这两个方法都不支持Symbol属性，而是在ECMAScript 6中添加一个Object.getOwnProperty-Symbols()方法来检索对象中的Symbol属性</p>
<p>Object.getOwnPropertySymbols()方法的返回值是一个包含所有Symbol自有属性的数组，就像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;uid&#x27;</span>)</span><br><span class="line">		object= &#123;</span><br><span class="line">     [uid] : <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">		&#125; </span><br><span class="line">		<span class="keyword">let</span> symbols = <span class="built_in">Object</span>.getOwnerPropertySymbols(objects)</span><br><span class="line">    <span class="built_in">console</span>.log(symbols.length) <span class="comment">//1</span></span><br><span class="line">    <span class="built_in">console</span>.log(symbols[<span class="number">0</span>]) <span class="comment">// &#x27;Symbol(uid)&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(object[symbols[<span class="number">0</span>]]) <span class="comment">//&#x27;12345&#x27;</span></span><br></pre></td></tr></table></figure>





<h4 id="通过well-known-symbol暴露内部操作"><a href="#通过well-known-symbol暴露内部操作" class="headerlink" title="通过well-known symbol暴露内部操作"></a>通过well-known symbol暴露内部操作</h4><ul>
<li>Symbol.hasInstance　一个在执行instanceof时调用的内部方法，用于检测对象的继承信息。</li>
<li>· Symbol.isConcatSpreadable　一个布尔值，用于表示当传递一个集合作为Array.prototype.concat()方法的参数时，是否应该将集合内的元素规整到同一层级。</li>
<li>· Symbol.iterator　一个返回迭代器（将在第8章讲解）的方法。</li>
<li>· Symbol.match　一个在调用String.prototype.match()方法时调用的方法，用于比较字符串。</li>
<li>Symbol.replace　一个在调用String.prototype.replace()方法时调用的方法，用于替换字符串的子串。</li>
<li>· Symbol.search　一个在调用String.prototype.search()方法时调用的方法，用于在字符串中定位子串。</li>
<li>· Symbol.species　用于创建派生类（将在第9章讲解）的构造函数。</li>
<li>· Symbol.split　一个在调用String.prototype.split()方法时调用的方法，用于分割字符串。</li>
<li>· Symbol.toPrimitive　一个返回对象原始值的方法。</li>
<li>· Symbol.toStringTag　一个在调用Object.prototype.toString()方法时使用的字符串，用于创建对象描述。</li>
<li> Symbol.unscopables　一个定义了一些不可被with语句引用的对象属性名称的对象集合。</li>
</ul>
<p>###Symbol.hasInstance</p>
<blockquote>
<p>每一个函数中都有一个Symbol.hasInstance方法，用于确定对象是否为函数的实例。该方法在Function.prototype中定义，所以所有函数都继承了instanceof属性的默认行为。为了确保Symbol.hasInstance不会被意外重写，该方法被定义为不可写、不可配置并且不可枚举</p>
<p>Symbol.hasInstance方法只接受一个参数，即要检查的值。如果传入的值是函数的实例，则返回true。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="built_in">Array</span>[symbol.hasInstance](obj)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>本质上，ECMAScript 6只是将instanceof操作符重新定义为此方法的简写语法。现在引入方法调用后，就可以随意改变instanceof的运行方式了</p>
<p>也可以重写所有内建函数（例如Date和Error函数）默认的Symbol.hasInstance属性。但是这样做的后果是代码的运行结果变得不可预期且有可能令人感到困惑，所以我们不推荐你这样做，最好的做法是，只在必要情况下改写你自己声明的函数的Symbol.hasInstance属性。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(MyObject, <span class="built_in">Symbol</span>.hasInstance, &#123;</span><br><span class="line">	value: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyObject()</span><br><span class="line"><span class="built_in">console</span>.log(obj <span class="keyword">instanceof</span> MyObject)</span><br></pre></td></tr></table></figure>



<h4 id="symbol-isconcatSpreadable属性"><a href="#symbol-isconcatSpreadable属性" class="headerlink" title="symbol.isconcatSpreadable属性"></a>symbol.isconcatSpreadable属性</h4><blockquote>
<p>也可以在派生数组子类中将Symbol.isConcatSpreadable设置为false，从而防止元素在调用concat()方法时被分解</p>
</blockquote>
<h4 id="暂时跳过"><a href="#暂时跳过" class="headerlink" title="暂时跳过"></a>暂时跳过</h4><h4 id="set和map集合"><a href="#set和map集合" class="headerlink" title="set和map集合"></a>set和map集合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">set.add(<span class="number">5</span>)</span><br><span class="line">set.add(<span class="string">&quot;5&quot;</span>)</span><br><span class="line">set.add(&#123;&#125;)</span><br><span class="line">set.add(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(set.size) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>实际上，Set构造函数可以接受所有可迭代对象作为参数，数组、Set集合、Map集合都是可迭代的，因而都可以作为Set构造函数的参数使用；构造函数通过迭代器从参数中提取值。第8章将详细讲解可迭代协议和迭代器协议。</p>
<p>调用delete()方法可以移除Set集合中的某一个元素，调用clear()方法会移除集合中的所有元素</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>])</span><br><span class="line"><span class="built_in">console</span>.log(set.size) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">5</span>)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">6</span>)) <span class="comment">//false</span></span><br><span class="line">set.delete(<span class="number">5</span>)</span><br><span class="line">set.clear(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>





<h4 id="set集合的foreEach-方法"><a href="#set集合的foreEach-方法" class="headerlink" title="set集合的foreEach()方法"></a>set集合的foreEach()方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">set.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key,ownerSet</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key + <span class="string">&#x27;&#x27;</span> + value)</span><br><span class="line">	<span class="built_in">console</span>.log(ownerSet ===  set)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h4 id="将set集合转换为数组"><a href="#将set集合转换为数组" class="headerlink" title="将set集合转换为数组"></a>将set集合转换为数组</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>])</span><br><span class="line">	array = [...set]</span><br><span class="line">	<span class="built_in">console</span>.log(array) <span class="comment">//[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure>



<h4 id="weak-set集合-只存储对象的弱引用"><a href="#weak-set集合-只存储对象的弱引用" class="headerlink" title="weak set集合(只存储对象的弱引用)"></a>weak set集合(只存储对象的弱引用)</h4><blockquote>
<p>在这个示例中，将变量key设置为null时便清除了对初始对象的引用，但是Set集合却保留了这个引用，你仍然可以使用展开运算符将Set集合转换成数组格式并从数组的首个元素取出该引用。大部分情况下这段代码运行良好，但有时候你会希望当其他所有引用都不再存在时，让Set集合中的这些引用随之消失。</p>
<p>举个例子，如果你在Web页面中通过JavaScript代码记录了一些DOM元素，这些元素有可能被另一段脚本移除，而你又不希望自己的代码保留这些DOM元素的最后一个引用。（这个情景被称作内存泄露。）</p>
<p>为了解决这个问题，ECMAScript 6中引入了另外一个类型：Weak Set集合（弱引用Set集合）。Weak Set集合只存储对象的弱引用，并且不可以存储原始值；集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">	key = &#123;&#125;</span><br><span class="line">set.add(key)</span><br><span class="line"><span class="built_in">console</span>.log(set.size)</span><br><span class="line">key = <span class="literal">null</span> <span class="comment">//移除原始引用</span></span><br><span class="line"><span class="built_in">console</span>.log(set.size) <span class="comment">//1</span></span><br><span class="line">key = [...set][<span class="number">0</span>] <span class="comment">//重新取回原始引用</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> weakSet()</span><br><span class="line">	key = &#123;&#125;</span><br><span class="line">set.add(key)</span><br><span class="line"><span class="built_in">console</span>.log(set.has(key)) <span class="comment">//true</span></span><br><span class="line">set.delete(key)</span><br><span class="line"><span class="built_in">console</span>.log(set.has(key)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> key1 = &#123;&#125;,</span><br><span class="line">		key2 = &#123;&#125;,</span><br><span class="line">		set = <span class="keyword">new</span> weakSet([key1,key2])</span><br><span class="line"><span class="built_in">console</span>.log(set.has(key1)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(key2)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>在这个示例中，向WeakSet构造函数传入一个含有两个对象的数组，最终创建一个包含这两个对象的Weak Set集合。请记住，WeakSet构造函数不接受任何原始值，如果数组中包含其他非对象值，程序会抛出错误。</p>
</blockquote>
<h4 id="set和weakset最主要的区别"><a href="#set和weakset最主要的区别" class="headerlink" title="set和weakset最主要的区别"></a>set和weakset最主要的区别</h4><blockquote>
<p>这段代码执行过后，就无法访问Weak Set中key的引用了。由于我们需要向has()方法传递一个强引用才能验证这个弱引用是否已被移除，因此测试有点儿难以进行下去，但是请你相信，JavaScript引擎一定会正确地移除最后一个弱引用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> weakSet()</span><br><span class="line">	key = &#123;&#125;</span><br><span class="line">set.add(key)</span><br><span class="line"><span class="built_in">console</span>.log(set.has(key)) <span class="comment">//true</span></span><br><span class="line">key = <span class="literal">null</span> <span class="comment">//移除对象key最后一个强引用</span></span><br></pre></td></tr></table></figure>



<ul>
<li>在WeakSet的实例中，如果向add()、has()和delete()这3个方法传入非对象参数都会导致程序报错。</li>
<li>· Weak Set集合不可迭代，所以不能被用于for-of循环。</li>
<li>· Weak Set集合不暴露任何迭代器（例如keys()和values()方法），所以无法通过程序本身来检测其中的内容。</li>
<li>· Weak Set集合不支持forEach()方法。</li>
<li>· Weak Set集合不支持size属性。</li>
</ul>
<h4 id="map集合"><a href="#map集合" class="headerlink" title="map集合"></a>map集合</h4><blockquote>
<p>如果要向Map集合中添加新的元素，可以调用set()方法并分别传入键名和对应值作为两个参数；如果要从集合中获取信息，可以调用get()方法。就像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">	key1 = &#123;&#125;</span><br><span class="line">	key2 = &#123;&#125;</span><br><span class="line">map.set(<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;深入理解es6&#x27;</span>)</span><br><span class="line">map.set(<span class="string">&#x27;year&#x27;</span>, <span class="number">2021</span>)</span><br><span class="line">map.set(key1, <span class="number">5</span>)</span><br><span class="line">map.set(key2, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;title&#x27;</span>)) <span class="comment">//&#x27;深入理解es6&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">&#x27;year&#x27;</span>)) <span class="comment">//2021</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key1)) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(key2)) <span class="comment">//6</span></span><br></pre></td></tr></table></figure>

<ul>
<li> has(key)　检测指定的键名在Map集合中是否已经存在。</li>
<li>· delete(key)　从Map集合中移除指定键名及其对应的值。</li>
<li>· clear()　移除Map集合中的所有键值对</li>
</ul>
<h4 id="map集合的初始化"><a href="#map集合的初始化" class="headerlink" title="map集合的初始化"></a>map集合的初始化</h4><blockquote>
<p>可以向Map构造函数传入数组来初始化一个Map集合，这一点同样与Set集合相似。数组中的每个元素都是一个子数组，子数组中包含一个键值对的键名与值两个元素。</p>
</blockquote>
<h4 id="map集合的forreach方法"><a href="#map集合的forreach方法" class="headerlink" title="map集合的forreach方法"></a>map集合的forreach方法</h4><ul>
<li>Map集合的forEach()方法与Set集合和数组中的forEach()方法类似，回调函数都接受3个参数：<ul>
<li>· Map集合中下一次索引的位置·</li>
<li> 值对应的键名</li>
<li>· Map集合本身</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key,ownerSet</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key + <span class="string">&#x27;&#x27;</span> + value)</span><br><span class="line">	<span class="built_in">console</span>.log(ownerSet ===  set)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>



<h4 id="weak-map集合"><a href="#weak-map集合" class="headerlink" title="weak map集合"></a>weak map集合</h4><blockquote>
<p>Weak Map集合最大的用途是保存Web页面中的DOM元素，例如，一些为Web页面打造的JavaScript库，会通过自定义的对象保存每一个引用的DOM元素。</p>
<p>ECMAScript 6中的Weak Map类型是一种存储着许多键值对的无序列表，列表的键名必须是非null类型的对象，键名对应的值则可以是任意类型。Weak Map的接口与Map非常相似，通过set()方法添加数据，通过get()方法获取数据</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span><br><span class="line">	element = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.element&#x27;</span>)</span><br><span class="line">map.set(element, <span class="string">&#x27;origina&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map.has(element)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(element)) <span class="comment">//&#x27;origina&#x27;</span></span><br><span class="line">map.delete(element)</span><br><span class="line"><span class="built_in">console</span>.log(map.has(element)) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(element)) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>



<h4 id="8-迭代器-iterator"><a href="#8-迭代器-iterator" class="headerlink" title="8.迭代器(iterator)"></a>8.迭代器(iterator)</h4><blockquote>
<p>迭代器是一种特殊对象，它具有一些专门为迭代过程设计的专有接口，所有的迭代器对象都有一个next()方法，每次调用都返回一个结果对象。结果对象有两个属性：一个是value，表示下一个将要返回的值；另一个是done，它是一个布尔类型的值，当没有更多可返回数据时返回true。迭代器还会保存一个内部指针，用来指向当前集合中值的位置，每调用一次next()方法，都会返回下一个可用的值。</p>
<p>如果在最后一个值返回后再调用next()方法，那么返回的对象中属性done的值为true，属性value则包含迭代器最终返回的值，这个返回值不是数据集的一部分，它与函数的返回值类似，是函数调用过程中最后一次给调用者传递信息的方法，如果没有相关数据则返回undefined。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">var</span> done = ( i &gt;= items.length)</span><br><span class="line">			<span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			done: done,</span><br><span class="line">			value: value</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:2,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:3,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value:undfined,done:true&#125;</span></span><br><span class="line"><span class="comment">//调用到最后一次，再次调用，返回最后一次调用结果</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value: undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="生成器（generator）"><a href="#生成器（generator）" class="headerlink" title="生成器（generator）"></a>生成器（generator）</h4><blockquote>
<p>生成器是一种返回迭代器的函数，通过function关键字后的星号（*）来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格，就像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成器的调用方式与普通函数相同，只不过返回的是一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>



<h4 id="yield的使用限制"><a href="#yield的使用限制" class="headerlink" title="yield的使用限制"></a>yield的使用限制</h4><blockquote>
<p>yield关键字只可在生成器内部使用，在其他地方使用会导致程序抛出语法错误，即便在生成器内部的函数里使用也是如此</p>
<p>从字面上看，yield关键字确实在createIterator()函数内部，但是它与return关键字一样，二者都不能穿透函数边界。嵌套函数中的return语句不能用作外部函数的返回语句，而此处嵌套函数中的yield语句会导致程序抛出语法错误。</p>
<p>不能用箭头函数来创建生成器。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">yield</span> item + <span class="number">1</span><span class="comment">//语法错误</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="生成器函数表达式"><a href="#生成器函数表达式" class="headerlink" title="生成器函数表达式"></a>生成器函数表达式</h4><blockquote>
<p>在这段代码中，createIterator()是一个生成器函数表达式，而不是一个函数声明。由于函数表达式是匿名的，因此星号直接放在function关键字和小括号之间。此外，这个示例基本与前例相同，使用的也是for循环。</p>
<p>不能用箭头函数来创建生成器。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createIterator = <span class="function"><span class="keyword">function</span>*(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; items.length;i++) &#123;</span><br><span class="line">		<span class="keyword">yield</span> items[i]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 1,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 2,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 3,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value: undefined,done:true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&#123;value: undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="生成器对象的方法"><a href="#生成器对象的方法" class="headerlink" title="生成器对象的方法"></a>生成器对象的方法</h4><blockquote>
<p>由于生成器本身就是函数，因而可以将它们添加到对象中。例如，在ECMAScript5风格的对象字面量中，可以通过函数表达式来创建生成器，就像这样：</p>
<p>也可以用ECMAScript 6的函数方法的简写方式来创建生成器，只需在函数名前添加一个星号（*）。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">	<span class="comment">//es5</span></span><br><span class="line">	createIterator: <span class="function"><span class="keyword">function</span> *(<span class="params">items</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; items.length;i++) &#123;</span><br><span class="line">			<span class="keyword">yield</span> items[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//es6</span></span><br><span class="line">	*createIterator: (items) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; items.length;i++) &#123;</span><br><span class="line">			<span class="keyword">yield</span> items[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = o.createIterator[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>



<h4 id="可迭代对象和for-of循环"><a href="#可迭代对象和for-of循环" class="headerlink" title="可迭代对象和for-of循环"></a>可迭代对象和for-of循环</h4><blockquote>
<p>可迭代对象具有Symbol.iterator属性，是一种与迭代器密切相关的对象。Symbol.iterator通过指定的函数可以返回一个作用于附属对象的迭代器。在ECMAScript 6中，所有的集合对象（数组、Set集合及Map集合）和字符串都是可迭代对象，这些对象中都有默认的迭代器。ECMAScript中新加入的特性for-of循环需要用到可迭代对象的这些功能。</p>
<p>由于生成器默认会为Symbol.iterator属性赋值，因此所有通过生成器创建的迭代器都是可迭代对象</p>
<p>如果将for-of语句用于不可迭代对象、null或undefined将会导致程序抛出错误。</p>
</blockquote>
<h4 id="访问默认迭代器"><a href="#访问默认迭代器" class="headerlink" title="访问默认迭代器"></a>访问默认迭代器</h4><blockquote>
<p>可以通过Symbol.iterator来访问对象默认的迭代器，就像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> iterator = value[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 1,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 1,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 1,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: undefined,done: true&#125;&quot;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	retrun <span class="keyword">typeof</span> object[<span class="built_in">Symbol</span>.iterator] === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">WeakMap</span>()) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">WeakSet</span>()) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h4 id="创建可迭代对象"><a href="#创建可迭代对象" class="headerlink" title="创建可迭代对象"></a>创建可迭代对象</h4><blockquote>
<p>默认情况下，开发者定义的对象都是不可迭代对象，但如果给Symbol.iterator属性添加一个生成器，则可以将其变为可迭代对象，例如</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> collection = &#123;</span><br><span class="line">	items: [],</span><br><span class="line">	*[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> items) &#123;</span><br><span class="line">			<span class="keyword">yield</span> item</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x) <span class="comment">//1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="内建迭代器"><a href="#内建迭代器" class="headerlink" title="内建迭代器"></a>内建迭代器</h4><blockquote>
<p>迭代器是ECMAScript 6的一个重要组成部分，在ECMAScript 6中，已经默认为许多内建类型提供了内建迭代器，只有当这些内建迭代器无法实现你的目标时才需要自己创建。通常来说当你定义自己的对象和类时才会遇到这种情况，否则，完全可以依靠内建的迭代器完成工作，而最常使用的可能是集合的那些迭代器。</p>
</blockquote>
<h4 id="集合对象迭代器"><a href="#集合对象迭代器" class="headerlink" title="集合对象迭代器"></a>集合对象迭代器</h4><ul>
<li><p>在ECMAScript 6中有3种类型的集合对象：数组、Map集合与Set集合。为了更好地访问对象中的内容，这3种对象都内建了以下三种迭代器：</p>
<ul>
<li>· entries()　返回一个迭代器，其值为多个键值对。</li>
<li>· values()　返回一个迭代器，其值为集合的值。</li>
<li>· keys()　返回一个迭代器，其值为集合中的所有键名。</li>
</ul>
</li>
<li><p>每次调用next()方法时，entries()迭代器都会返回一个数组，数组中的两个元素分别表示集合中每个元素的键与值。如果被遍历的对象是数组，则第一个元素是数字类型的索引；如果是Set集合，则第一个元素与第二个元素都是值（Set集合中的值被同时作为键与值使用）；如果是Map集合，则第一个元素为键名。</p>
</li>
</ul>
<h4 id="字符串迭代器"><a href="#字符串迭代器" class="headerlink" title="字符串迭代器"></a>字符串迭代器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;a 吉 b&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; message.length;i++) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(message[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a(空)(空)(空)(空)b ,由于双字节字符被视作两个独立的编码单元，从而最终在A与B之间打印出4个空行。</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;a 吉 b&#x27;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> c <span class="keyword">of</span> message） &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(message[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a(空)(吉)(空)b </span></span><br></pre></td></tr></table></figure>



<h4 id="NodeList迭代器"><a href="#NodeList迭代器" class="headerlink" title="NodeList迭代器"></a>NodeList迭代器</h4><blockquote>
<p>DOM标准中有一个NodeList类型，document对象中的所有元素都用这个类型来表示。对于编写Web浏览器环境中的JavaScript的开发者来说，需要花一点儿功夫去理解NodeList对象和数组之间的差异。二者都使用length属性来表示集合中元素的数量，都可以通过方括号来访问集合中的独立元素；而在内部实现中，二者的表现非常不一致，因而会造成很多困扰。</p>
</blockquote>
<h4 id="给迭代器传递参数"><a href="#给迭代器传递参数" class="headerlink" title="给迭代器传递参数"></a>给迭代器传递参数</h4><blockquote>
<p>如果给迭代器的next()方法传递参数，则这个参数的值就会替代生成器内部上一条yield语句的返回值。</p>
</blockquote>
<h4 id="在迭代器中抛出错误"><a href="#在迭代器中抛出错误" class="headerlink" title="在迭代器中抛出错误"></a>在迭代器中抛出错误</h4><blockquote>
<p>在这个示例中，前两个表达式正常求值，而调用throw()方法后，在继续执行letsecond求值前，错误就会被抛出并阻止了代码继续执行。这个过程与直接抛出错误很相似，二者唯一的区别是抛出的时机不同。图8-2展示了代码的每一步执行过程。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> first = <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">let</span> second = <span class="keyword">yield</span> first + <span class="number">2</span></span><br><span class="line">	<span class="keyword">yield</span> second + <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生成器的调用方式与普通函数相同，只不过返回的是一个迭代器</span></span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="number">4</span>)) <span class="comment">//6</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;boom&#x27;</span>))) <span class="comment">//从生成器中抛出错误</span></span><br></pre></td></tr></table></figure>

<h4 id="生成器返回语句"><a href="#生成器返回语句" class="headerlink" title="生成器返回语句"></a>生成器返回语句</h4><blockquote>
<p>展开运算符与for-of循环语句会直接忽略通过return语句指定的任何返回值，只要done一变为true就立即停止读取其他的值。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> iterator = createIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 1,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 42,done: true&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: undfined,done: true&#125;&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="委托生成器"><a href="#委托生成器" class="headerlink" title="委托生成器"></a>委托生成器</h4><blockquote>
<p>在某些情况下，我们需要将两个迭代器合二为一，这时可以创建一个生成器，再给yield语句添加一个星号，就可以将生成数据的过程委托给其他生成器。当定义这些生成器时，只需将星号放置在关键字yield和生成器的函数名之间即可，就像这样</p>
<p>yield *也可直接应用于字符串，例如yield * “hello”，此时将使用字符串的默认迭代器</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createNumberIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createColorIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;red&#x27;</span></span><br><span class="line">	<span class="keyword">yield</span> <span class="string">&#x27;green&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">createCombinedIterator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> *createNumberIterator()</span><br><span class="line">	<span class="keyword">yield</span> *createColorIterator()</span><br><span class="line">  <span class="keyword">yield</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iterator = createCombinedIterator()</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 1,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: 2,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: &#x27;red&#x27;,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: &#x27;green&#x27;,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: true,done: false&#125;&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">//&quot;&#123;value: undefined,done: false&#125;&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="异步任务执行"><a href="#异步任务执行" class="headerlink" title="异步任务执行"></a>异步任务执行</h4><blockquote>
<p>执行异步操作的传统方式一般是调用一个函数并执行相应回调函数。举个例子，我们用Node.js编写一段从磁盘读取文件的代码：</p>
<p>调用fs.readFile()方法时要求传入要读取的文件名和一个回调函数，操作结束后会调用该回调函数并检查是否存在错误，如果没有就可以处理返回的内容。如果要执行的任务很少，那么这样的方式可以很好地完成任务；如若需要嵌套回调或序列化一系列的异步操作，事情会变得非常复杂。此时，生成器和yield语句就派上用场了。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line">fs.readFile(<span class="string">&#x27;config.josn&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,contents</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(err) &#123;</span><br><span class="line">		<span class="keyword">throw</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	dosomethingwith(contents)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="简单任务执行器"><a href="#简单任务执行器" class="headerlink" title="简单任务执行器"></a>简单任务执行器</h4><blockquote>
<p>于执行yield语句会暂停当前函数的执行过程并等待下一次调用next()方法，因此你可以创建一个函数，在函数中调用生成器生成相应的迭代器，从而在不用回调函数的基础上实现异步调用next()方法，就像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个无使用限制的迭代器</span></span><br><span class="line">	<span class="keyword">let</span> task = taskDef()</span><br><span class="line">	<span class="comment">//开始执行任务</span></span><br><span class="line">	<span class="keyword">let</span> result = task.next()</span><br><span class="line">	<span class="comment">//循环调用next函数</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">//如果任务未执行，则继续执行</span></span><br><span class="line">		<span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">			result = task.next()</span><br><span class="line">			step()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//开始迭代执行</span></span><br><span class="line">  step()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="向任务执行器传递数据"><a href="#向任务执行器传递数据" class="headerlink" title="向任务执行器传递数据"></a>向任务执行器传递数据</h4><blockquote>
<p>给任务执行器传递数据的最简单办法是，将值通过迭代器的next()方法传入作为yield的生成值供下次调用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个无使用限制的迭代器</span></span><br><span class="line">	<span class="keyword">let</span> task = taskDef()</span><br><span class="line">	<span class="comment">//开始执行任务</span></span><br><span class="line">	<span class="keyword">let</span> result = task.next()</span><br><span class="line">	<span class="comment">//循环调用next函数</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">//如果任务未执行，则继续执行</span></span><br><span class="line">		<span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">			result = task.next(result.value) <span class="comment">//向next()方法传递数据</span></span><br><span class="line">			step()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//开始迭代执行</span></span><br><span class="line">  step()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异步任务执行器"><a href="#异步任务执行器" class="headerlink" title="异步任务执行器"></a>异步任务执行器</h4><blockquote>
<p>之前的示例只是在多个yield调用间来回传递静态数据，而等待一个异步过程有些不同。任务执行器需要知晓回调函数是什么以及如何使用它。由于yield表达式会将值返回给任务执行器，所有的函数调用都会返回一个值，因而在某种程度上这也是一个异步操作，任务执行器会一直等待直到操作完成。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fetchData() &#123;</span><br><span class="line">	return function(callback) &#123;</span><br><span class="line">		setTimeout(function()&#123;</span><br><span class="line">			callback(null, &#39;hi&#39;)</span><br><span class="line">		&#125;, 50)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>通过===操作符检查后，如果result.value是一个函数，会传入一个回调函数作为参数来调用它，回调函数遵循Node.js中有关执行错误的约定：所有可能的错误放在第一个参数（err）中，结果放在第二个参数中。如果传入了err，则意味着执行过程中产生了错误，这时会通过task.throw()正确输出错误对象；如果没有错误产生，data被传入task.next()作为结果储存起来，并继续执行step()方法。如果result.value不是一个函数，则直接将其传入next()方法。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">taskDef</span>) </span>&#123;</span><br><span class="line">	<span class="comment">//创建一个无使用限制的迭代器</span></span><br><span class="line">	<span class="keyword">let</span> task = taskDef()</span><br><span class="line">	<span class="comment">//开始执行任务</span></span><br><span class="line">	<span class="keyword">let</span> result = task.next()</span><br><span class="line">	<span class="comment">//循环调用next函数</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">//如果任务未执行，则继续执行</span></span><br><span class="line">		<span class="keyword">if</span>(!result.done) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> result.value === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">				result.value(<span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)) </span>&#123;</span><br><span class="line">        	<span class="keyword">if</span>(err) &#123;</span><br><span class="line">						result = task.throw(err)</span><br><span class="line">          	<span class="keyword">return</span></span><br><span class="line">        	&#125; </span><br><span class="line">        	result = task.next(data)</span><br><span class="line">        	step()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       	result = task.next(result.value) <span class="comment">//向next()方法传递数据</span></span><br><span class="line">				step() </span><br><span class="line">      &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//开始迭代执行</span></span><br><span class="line">  step()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>Symbol.iterator被用来定义对象的默认迭代器，内建对象和开发者定义的对象都支持这个特性，通过这个Symbol定义的方法可以返回一个迭代器。如果对象中有Symbol.iterator这个属性，则此对象为可迭代对象。</p>
<p>for-of循环可以持续获取可迭代对象中的值，与传统的for循环迭代相比，for-of循环不需要追踪值在集合中的位置，也不需要控制循环结束的时机，使用起来非常方便，它会自动地从迭代器中读取所有值，如果没有更多可返回的值就自动退出循环</p>
<p>为了降低for-of的使用成本，ECMAScript 6中的许多值都有默认迭代器。所有的集合类型（例如数组、Map集合与Set集合）都有默认迭代器，字符串同样也有默认迭代器，其可以直接迭代字符串中的字符，避免了遍历编码单元带来的诸多问题。</p>
<p>展开运算符也可以作用于可迭代对象，通过迭代器从对象中读取相应的值并插入到一个数组中。</p>
<p>生成器是一类特殊函数，在定义时需要额外添加一个星号（*），被调用时会自动创建一个迭代器，并通过关键字yield来标识每次调用迭代器的next()方法时的返回值。</p>
<p>借助生成器委托这个新特性，便可重用已有生成器来创建新的生成器，从而进一步封装更复杂的迭代器行为。新语法使用yield *来标识生成的值，新迭代器的返回值便可取自已有的多个迭代器。</p>
<p>在生成器和迭代器的所有应用场景中，最有趣且最令人兴奋的可能是用来创建更简洁的异步代码。这种方式无须在所有地方定义回调函数，其代码看起来像是同步代码，但实际上使用了yield生成的特性来等待异步操作最终完成。</p>
</blockquote>
<h4 id="javascript中的类"><a href="#javascript中的类" class="headerlink" title="javascript中的类"></a>javascript中的类</h4><ul>
<li>函数声明可以被提升，而类声明与let声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区中</li>
<li>类声明中的所有代码将自动运行在严格模式下，而且无法强行让代码脱离严格模式执行。</li>
<li> 在自定义类型中，需要通过Object.defineProperty()方法手工指定某个方法为不可枚举；而在类中，所有方法都是不可枚举的。</li>
<li>每个类都有一个名为[[Construct]]的内部方法，通过关键字new调用那些不含[[Construct]]的方法会导致程序抛出错误。</li>
<li>使用除关键字new以外的方式调用类的构造函数会导致程序抛出错误。</li>
<li>在类中修改类名会导致程序报错。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//外部作用域中的let声明-外部可以修改类名</span></span><br><span class="line"><span class="keyword">let</span> personType2 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">	&#x27;use strict&#x27;</span></span><br><span class="line">  <span class="comment">//立即执行函数表达式（IIFE）中的const声明，内部不可修改类名</span></span><br><span class="line">	<span class="keyword">const</span> PersonType2 = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; </span><br><span class="line">	<span class="comment">//	确保通过关键字new调用该函数</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须通过关键字new调用构造函数&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">this</span>.name = name</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">	<span class="built_in">Object</span>.defineProperty(PersonType2.prototype, <span class="string">&#x27;sayName&#x27;</span>, &#123;</span><br><span class="line">		value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">new</span>.target === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须通过关键字new调用构造函数&#x27;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">		&#125;</span><br><span class="line">		enumable: <span class="literal">false</span>,</span><br><span class="line">		writeable: <span class="literal">true</span>,</span><br><span class="line">		configurabel: <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> PersonType2</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>





<h4 id="类表达式"><a href="#类表达式" class="headerlink" title="类表达式"></a>类表达式</h4><ul>
<li>类和函数都有两种存在形式：声明形式和表达式形式。<ul>
<li>声明形式的函数和类都由相应的关键字（分别为function和class）进行定义，随后紧跟一个标识符；</li>
<li>表达式形式的函数和类与之类似，只是不需要在关键字后添加标识符。类表达式的设计初衷是为了声明相应变量或传入函数作为参数。</li>
</ul>
</li>
</ul>
<h4 id="命名类表达式"><a href="#命名类表达式" class="headerlink" title="命名类表达式"></a>命名类表达式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personClass = <span class="class"><span class="keyword">class</span> <span class="title">personClass2</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> personClass) <span class="comment">//&#x27;function&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> personClass2) <span class="comment">//&#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h4><blockquote>
<p>尽管应该在类构造函数中创建自己的属性，但是类也支持直接在原型上定义访问器属性。创建getter时，需要在关键字get后紧跟一个空格和相应的标识符；创建setter时，只需把关键字get替换为set即可，就像这样</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> propertyName = <span class="string">&#x27;html&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomHTMLElement</span>() </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.element = element</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">html</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.element.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">html</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">  set [propertyName](value) &#123;</span><br><span class="line">    <span class="built_in">this</span>.element.innerHTML = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</span></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(CustomHTMLElement.prototype, <span class="string">&#x27;html&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span> <span class="keyword">in</span> descriptor) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span> <span class="keyword">in</span> descriptor) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(descriptor.enumerable) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h4 id="可计算成员名称"><a href="#可计算成员名称" class="headerlink" title="可计算成员名称"></a>可计算成员名称</h4><blockquote>
<p>类和对象字面量还有更多相似之处，类方法和访问器属性也支持使用可计算名称。就像在对象字面量中一样，用方括号包裹一个表达式即可使用可计算名称，例如</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> methodName = <span class="string">&#x27;sayname&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">personClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name</span><br><span class="line">	&#125;</span><br><span class="line">	[methodName]() &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> me = <span class="keyword">new</span> personClass(<span class="string">&#x27;niculas&#x27;</span>)</span><br><span class="line">me.sayname() <span class="comment">// niculas</span></span><br></pre></td></tr></table></figure>



<h4 id="生成器方法"><a href="#生成器方法" class="headerlink" title="生成器方法"></a>生成器方法</h4><blockquote>
<p>回忆第8章，在对象字面量中，可以通过在方法名前附加一个星号（*）的方式来定义生成器，在类中亦是如此，可以将任何方法定义成生成器。请看这个示例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">	*<span class="function"><span class="title">createIterator</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">		<span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">		<span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> myClass()</span><br><span class="line"><span class="keyword">let</span> iterator = instance.createIterator()</span><br></pre></td></tr></table></figure>



<blockquote>
<p>但如果你的类是用来表示值的集合的，那么为它定义一个默认迭代器会更有用。通过Symbol.iterator定义生成器方法即可为类定义默认迭代器：</p>
<p>如果不介意在对象的实例中出现添加的方法和访问器属性，则可以将它们添加到类的原型中；如果你希望它们只出现在类中，那么需要使用静态成员。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.items = []</span><br><span class="line">	&#125;</span><br><span class="line">	*[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">		<span class="keyword">yield</span> *<span class="built_in">this</span>.items.value</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> collection  = <span class="keyword">new</span> Collection()</span><br><span class="line">collection.items.push(<span class="number">1</span>)</span><br><span class="line">collection.items.push(<span class="number">2</span>)</span><br><span class="line">collection.items.push(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> collection) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(x) <span class="comment">//1,2,3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h4><blockquote>
<p>在ECMAScript 5及早期版本中，直接将方法添加到构造函数中来模拟静态成员是一种常见的模式，例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">personClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	 <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//静态方法</span></span><br><span class="line">personType.create = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> personType(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例方法</span></span><br><span class="line">personType.prototype.syaname = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> personType.create(<span class="string">&#x27;niculas&#x27;</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>ECMAScript 6的类语法简化了创建静态成员的过程，在方法或访问器属性名前使用正式的静态注释即可。下面这个类等价于之前的示例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">personClass</span> </span>&#123;</span><br><span class="line">	 <span class="comment">//等价于personType构造函数</span></span><br><span class="line">		<span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">			<span class="built_in">this</span>.name = name</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//等价于persontype.prototype.sayname</span></span><br><span class="line">		<span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> personClass(name)</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = personClass.create(<span class="string">&#x27;nicolas&#x27;</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p> 不可在实例中访问静态成员，必须要直接在类中访问静态成员</p>
</blockquote>
<h4 id="继承与派生类"><a href="#继承与派生类" class="headerlink" title="继承与派生类"></a>继承与派生类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Reactangle</span>(<span class="params">length, width</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.length = length</span><br><span class="line">	<span class="built_in">this</span>.width = width</span><br><span class="line">&#125;</span><br><span class="line">Reactangle.prototype.getarea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.length * <span class="built_in">this</span>.width</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">length</span>) </span>&#123;</span><br><span class="line">	Reactangle.call(<span class="built_in">this</span>, length, length)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//必须用一个创建自Rectangle.prototype的新对象重写Square.prototype并调用Rectangle.call()方法</span></span><br><span class="line">square.prototype = object.create(reactangle.prototype, &#123;</span><br><span class="line">	<span class="title">constructor</span>: &#123;</span><br><span class="line">		value:square,</span><br><span class="line">		enumerable: <span class="literal">true</span>,</span><br><span class="line">		writeable: <span class="literal">true</span>,</span><br><span class="line">		configurable: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getarea()) <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Reactangle) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>类的出现让我们可以更轻松地实现继承功能，使用熟悉的extends关键字可以指定类继承的函数。原型会自动调整，通过调用super()方法即可访问基类的构造函数。这段代码是之前示例的ECMAScript 6等价版本：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactangle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.length = length</span><br><span class="line">		<span class="built_in">this</span>.width = width</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.length * <span class="built_in">this</span>.width</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Reactangle</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">			<span class="comment">//	Reactangle.call(this, length, length)</span></span><br><span class="line">			<span class="built_in">super</span>(length,length)</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//类方法遮蔽</span></span><br><span class="line">    <span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.length * <span class="built_in">this</span>.length</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(square.getArea()) <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.log(square <span class="keyword">instanceof</span> Square) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>继承自其他类的类被称作派生类，如果在派生类中指定了构造函数则必须要调用super()，如果不这样做程序就会报错。如果选择不使用构造函数，则当创建新的类实例时会自动调用super()并传入所有参数。举个例子，以下两个类完全相同：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">	<span class="comment">//	没有构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Recrangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="使用super小贴士"><a href="#使用super小贴士" class="headerlink" title="使用super小贴士"></a>使用super小贴士</h4><ul>
<li>只可在派生类的构造函数中使用super()，如果尝试在非派生类（不是用extends声明的类）或函数中使用则会导致程序抛出错误。</li>
<li>· 在构造函数中访问this之前一定要调用super()，它负责初始化this，如果在调用super()之前尝试访问this会导致程序出错。</li>
<li>· 如果不想调用super()，则唯一的方法是让类的构造函数返回一个对象。</li>
</ul>
<h4 id="类方法遮蔽"><a href="#类方法遮蔽" class="headerlink" title="类方法遮蔽"></a>类方法遮蔽</h4><blockquote>
<p>派生类中的方法总会覆盖基类中的同名方法。举个例子，给Square添加getArea()方法来重新定义这个方法的功能</p>
</blockquote>
<h4 id="静态成员继承"><a href="#静态成员继承" class="headerlink" title="静态成员继承"></a>静态成员继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactangle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.length = length</span><br><span class="line">		<span class="built_in">this</span>.width = width</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.length * <span class="built_in">this</span>.width</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params">length, width</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Rectangle(length,width)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Reactangle</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">			<span class="comment">//	Reactangle.call(this, length, length)</span></span><br><span class="line">			<span class="built_in">super</span>(length,length)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">var</span> rect = Square.create(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Reactangle) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(rect.getArea()) <span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(rect <span class="keyword">instanceof</span> Square) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h4 id="派生自表达式的类-继承自其他类的类被称作派生类-我是一个类，我继承了其他类，我就是一个派生类"><a href="#派生自表达式的类-继承自其他类的类被称作派生类-我是一个类，我继承了其他类，我就是一个派生类" class="headerlink" title="派生自表达式的类-(继承自其他类的类被称作派生类)(我是一个类，我继承了其他类，我就是一个派生类)"></a>派生自表达式的类-(继承自其他类的类被称作派生类)(我是一个类，我继承了其他类，我就是一个派生类)</h4><blockquote>
<p>只要表达式可以被解析为一个函数并且具有[[Construct]]属性和原型，那么就可以用extends进行派生。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> serizlizableMixin = &#123;</span><br><span class="line">	<span class="function"><span class="title">serialize</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> areaMixin = &#123;</span><br><span class="line">	<span class="function"><span class="title">getArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.length * <span class="built_in">this</span>.width</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mixin</span>(<span class="params">...mixins</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> base = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">	<span class="built_in">Object</span>.assign(base.prototype, ...mixins)</span><br><span class="line">	<span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">mixin</span>(<span class="title">areaMixin</span>, <span class="title">serizlizableMixin</span>) </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>()</span><br><span class="line">		<span class="built_in">this</span>.length = length</span><br><span class="line">		<span class="built_in">this</span>.width = length</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Square(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.lgo(x.getArea()) <span class="comment">//9</span></span><br><span class="line"><span class="built_in">console</span>.lgo(x.serialize()) <span class="comment">//&#123;&#x27;length&#x27;:3,&#x27;width&#x27;:3&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>请记住，如果多个mixin对象具有相同属性，那么只有最后一个被添加的属性被保留。</p>
<p>在extends后可以使用任意表达式，但不是所有表达式最终都能生成合法的类。如果使用null或生成器函数（曾在第8章讲解）会导致错误发生，类在这些情况下没有[[Consturct]]属性，尝试为其创建新的实例会导致程序无法调用[[Construct]]而报错</p>
</blockquote>
<h4 id="内建对象的继承"><a href="#内建对象的继承" class="headerlink" title="内建对象的继承"></a>内建对象的继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = []</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length) <span class="comment">//1</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">Array</span>.apply(<span class="built_in">this</span>.argumnets)</span><br><span class="line">&#125;</span><br><span class="line">myArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">	<span class="title">constructor</span>: &#123;</span><br><span class="line">    value: myArray,</span><br><span class="line">    wirtable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> myArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length) <span class="comment">// 1</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]) <span class="comment">// &#x27;red&#x27;</span></span><br></pre></td></tr></table></figure>





<blockquote>
<p>这是因为通过传统JavaScript继承形式实现的数组继承没有从Array.apply()或原型赋值中继承相关功能。</p>
</blockquote>
<blockquote>
<p>先由基类（Array）创建this的值，然后派生类的构造函数（MyArray）再修改这个值。所以一开始可以通过this访问基类的所有内建功能，然后再正确地接收所有与之相关的功能。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> myArray()</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">&#x27;red&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(colors.length) <span class="comment">//1</span></span><br><span class="line">colors.length = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(colors[<span class="number">0</span>]) <span class="comment">// undfein</span></span><br></pre></td></tr></table></figure>



<h4 id="symboling-species属性"><a href="#symboling-species属性" class="headerlink" title="symboling.species属性"></a>symboling.species属性</h4><blockquote>
<p>内建对象继承的一个实用之处是，原本在内建对象中返回实例自身的方法将自动返回派生类的实例。所以，如果你有一个继承自Array的派生类MyArray，那么像slice()这样的方法也会返回一个MyArray的实例。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> MyArray(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">subitems = items.slice(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items <span class="keyword">instanceof</span> MyArray) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(subitems <span class="keyword">instanceof</span> MyArray) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Symbol.species是诸多内部Symbol中的一个，它被用于定义返回函数的静态访问器属性。被返回的函数是一个构造函数，每当要在实例的方法中（不是在构造函数中）创建类的实例时必须使用这个构造函数。以下这些内建类型均已定义Symbol.species属性：</p>
<blockquote>
<p>· Array</p>
<p>· ArrayBuffer</p>
<p>· Map</p>
<p>· Promise</p>
<p>· RegExp</p>
<p>· Set</p>
<p>· Typed arrays</p>
</blockquote>
</blockquote>
<blockquote>
<p>列表中的每个类型都有一个默认的Symbol.species属性，该属性的返回值为this，这也意味着该属性总会返回构造函数。如果在自定义的类中实现这个功能，则代码看起来可能是这样的：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> get[<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">clone</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">this</span>.constructor[<span class="built_in">Symbol</span>.species](<span class="built_in">this</span>.value)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDerivedClass2</span> <span class="keyword">extends</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myDerivedClass2</span> <span class="keyword">extends</span> <span class="title">myClass</span> </span>&#123;</span><br><span class="line"> <span class="comment">//重写返回类型，调用父类的  constructor</span></span><br><span class="line">	<span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> myClass</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> myDerivedClass1(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"> clone1 = instace1.clone()</span><br><span class="line"> instacne2 = <span class="keyword">new</span>  myDerivedClass2</span><br><span class="line"> clone2 = instace2.clone()</span><br><span class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> MyClass) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone1 <span class="keyword">instanceof</span> myDerivedClass1) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> MyClass) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(clone2 <span class="keyword">instanceof</span> myDerivedClass2) <span class="comment">//false,</span></span><br><span class="line"><span class="comment">//MyDerivedClass2继承MyClass时重写了Symbol.species让其返回MyClass，调用MyDerivedClass2实例的clone()方法时，返回值是一个MyClass的实例</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般来说，只要想在类方法中调用this.constructor，就应该使用Symbol.species属性，从而让派生类重写返回类型。而且如果你正从一个已定义Symbol.species属性的类创建派生类，那么要确保使用那个值而不是使用构造函数。</p>
</blockquote>
<h4 id="在类的构造函数中使用new-target"><a href="#在类的构造函数中使用new-target" class="headerlink" title="在类的构造函数中使用new.target"></a>在类的构造函数中使用new.target</h4><blockquote>
<p>因为类必须通过new关键字才能调用，所以在类的构造函数中，new.target属性永远不会是undefined。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rectangle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="title">constructor</span>(<span class="params">length,width</span>)</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">new</span>.target === rectangle)</span><br><span class="line">		<span class="built_in">this</span>.length = length</span><br><span class="line">		<span class="built_in">this</span>.width = width</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">square</span> <span class="keyword">extends</span> <span class="title">rectangle</span> </span>&#123;</span><br><span class="line">  	<span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">      <span class="comment">//super()调用执行了rectangle 的构造函数</span></span><br><span class="line">      <span class="built_in">super</span>(length, length)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//new.target的值是 rectangle</span></span><br><span class="line"><span class="comment">//因为每个构造函数都可以根据自身被调用的方式改变自己的行为</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> rectangle(<span class="number">3</span>,<span class="number">4</span>) <span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> square(<span class="number">3</span>,<span class="number">4</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>



<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p> ECMAScript 6的类语法通过在类的原型上定义非静态方法来与原型继承协同工作，而静态方法最终放在构造函数上。所有方法都不可枚举，从而可以更好地匹配内建对象的行为，因为那些方法通常是不可枚举的。此外，类构造函数必须通过new关键字调用，以确保不会意外将类作为函数去调用</p>
</blockquote>
<blockquote>
<p>基于类的继承支持从其他类、函数或表达式派生类，可以通过函数调用来确定最终要继承哪一个类，可以通过mixin对象和其他不同的组合模式来创建新的类，也可以继承诸如Array的内建对象并且像预期的那样运行。</p>
<p>在类的构造函数中，可以通过new.target来随着类被调用的多种方式而做出不同的对应。最常见的用法是创建一个抽象基类，如果直接实例化这个类会抛出错误，但是可以通过其他的类去实例化它。</p>
</blockquote>
<h4 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h4><blockquote>
<p>在ECMAScript 6以前，创建数组的方式主要有两种，一种是调用Array构造函数，另一种是用数组字面量语法，这两种方法均需列举数组中的元素，功能非常受限。如果想将一个类数组对象（具有数值型索引和length属性的对象）转换为数组，可选的方法也十分有限，经常需要编写额外的代码。为了进一步简化JavaScript数组的创建过程，ECMAScript 6新增了Array.of()和Array.from()两个方法。</p>
</blockquote>
<h4 id="Array-of-方法"><a href="#Array-of-方法" class="headerlink" title="Array.of()方法"></a>Array.of()方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items.length) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//&#x27;2&#x27;</span></span><br><span class="line"></span><br><span class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items.length) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">items = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//3</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]) <span class="comment">//&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果给Array构造函数传入一个数值型的值，那么数组的length属性会被设为该值；如果传入多个值，此时无论这些值是不是数值型的，都会变为数组的元素</p>
</blockquote>
<blockquote>
<p>Array.of()与Array构造函数的工作机制类似，只是不存在单一数值型参数值的特例，无论有多少参数，无论参数是什么类型的，Array.of()方法总会创建一个包含所有参数的数组。以下是一些Array.of()方法的调用示例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">items = <span class="built_in">Array</span>.of(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">items = <span class="built_in">Array</span>.of(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(items.length) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]) <span class="comment">//&#x27;2&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>(<span class="params">arrayCreator, value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> arrayCreator(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> items = createArray(<span class="built_in">Array</span>.of, value)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>[插图]Array.of()方法不通过Symbol.species属性（见第9章）确定返回值的类型，它使用当前构造函数（也就是of()方法中的this值）来确定正确的返回数据的类型。</p>
</blockquote>
<h4 id="Array-from-方法"><a href="#Array-from-方法" class="headerlink" title="Array.from()方法"></a>Array.from()方法</h4><blockquote>
<p>JavaScript不支持直接将非数组对象转换为真实数组，arguments就是一种类数组对象，如果要把它当作数组使用则必须先转换该对象的类型。在ECMAScript 5中，可能需要编写如下函数来把类数组对象转换为数组：</p>
<p>Array.from()方法可以接受可迭代对象或类数组对象作为第一个参数，最终返回一个数组。</p>
<p>Array.from()方法也是通过this来确定返回数组的类型的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeArray</span>(<span class="params">arrayLike</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> result = []</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;len = arrayLike.length;i &lt; len;i++) &#123;</span><br><span class="line">		result.push(arayLike[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">	<span class="comment">//调用数组原生的slice 将非数组转换为数组</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(arrayLike)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> args = makeArray(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.form(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="映射转换"><a href="#映射转换" class="headerlink" title="映射转换"></a>映射转换</h4><blockquote>
<p>如果想要进一步转化数组，可以提供一个映射函数作为Array.from()的第二个参数，这个函数用来将类数组对象中的每一个值转换成其他形式，最后将这些结果储存在结果数组的相应索引中,第三个参数来表示映射函数的this值。</p>
</blockquote>
<h4 id="用Array-from-转换可迭代对象"><a href="#用Array-from-转换可迭代对象" class="headerlink" title="用Array.from()转换可迭代对象"></a>用Array.from()转换可迭代对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let numbers &#x3D; &#123;</span><br><span class="line">	*[Symbol.iterator]() &#123;</span><br><span class="line">		yield 1;</span><br><span class="line">		yield 2;</span><br><span class="line">		yield 3;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let numbers2 &#x3D; Array.from(numbers, (value) &#x3D;&gt; value + 1)</span><br><span class="line">console.log(numbers2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果一个对象既是类数组又是可迭代的，那么Array.from()方法会根据迭代器来决定转换哪个值。</p>
</blockquote>
<h4 id="find-方法和findIndex-方法"><a href="#find-方法和findIndex-方法" class="headerlink" title="find()方法和findIndex()方法"></a>find()方法和findIndex()方法</h4><blockquote>
<p>find()方法和findIndex()方法都接受两个参数：一个是回调函数；另一个是可选参数，用于指定回调函数中this的值。执行回调函数时，传入的参数分别为：数组中的某个元素和该元素在数组中的索引及数组本身，与传入map()和forEach()方法的参数相同。如果给定的值满足定义的标准，回调函数应返回true，一旦回调函数返回true，find()方法和findIndex()方法都会立即停止搜索数组剩余的部分。</p>
<p>find()方法返回查找到的值，findIndex()方法返回查找到的值的索引。请看这个示例：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">25</span>,<span class="number">30</span>,<span class="number">35</span>,<span class="number">40</span>,<span class="number">45</span>]</span><br><span class="line"><span class="built_in">console</span>.log(numbers.find(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>)) <span class="comment">//35</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n &gt; <span class="number">33</span>)) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>



<h4 id="fill-方法"><a href="#fill-方法" class="headerlink" title="fill()方法"></a>fill()方法</h4><blockquote>
<p>fill()方法可以用指定的值填充一至多个数组元素。当传入一个值时，fill()方法会用这个值重写数组中的所有值，例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">numbers.fill(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString()) <span class="comment">//1,1,1,1</span></span><br><span class="line">numbers.fill(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString()) <span class="comment">//1,2,1,1</span></span><br><span class="line">numbers.fill(<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>) <span class="comment">//不包括3</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString()) <span class="comment">//1,0,0,1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果只想改变数组某一部分的值，可以传入开始索引和不包含结束索引（不包含结束索引当前值）这两个可选参数，</p>
<p>如果开始索引或结束索引为负值，那么这些值会与数组的length属性相加来作为最终位置。例如，如果开始位置为-1，那么索引的值实际为array.length-1，array为调用fill()方法的数组。</p>
</blockquote>
<h4 id="copyWithin-方法"><a href="#copyWithin-方法" class="headerlink" title="copyWithin()方法"></a>copyWithin()方法</h4><blockquote>
<p>而copyWithin()方法则是从数组中复制元素的值。调用copyWithin()方法时需要传入两个参数：一个是该方法开始填充值的索引位置，另一个是开始复制值的索引位置。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(number.toString()) <span class="comment">//1,2,1,2</span></span><br><span class="line">numbers.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//复制索引为2的值</span></span><br><span class="line"><span class="comment">//从索引0开始，到1结束</span></span><br><span class="line"><span class="built_in">console</span>.log(numbers.toString()) <span class="comment">//1,2,1,4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>copyWithin()会一直复制直到数组末尾的值，但是你可以提供可选的第三个参数来限制被重写元素的数量。第三个参数是不包含结束索引，用于指定停止复制值的位置</p>
</blockquote>
<h4 id="定型数组"><a href="#定型数组" class="headerlink" title="定型数组"></a>定型数组</h4><blockquote>
<p>定型数组是一种用于处理数值类型（正如其名，不是所有类型）数据的专用数组，最早是在WebGL中使用的，WebGL是OpenGL ES 2.0的移植版，在Web页面中通过<canvas>元素来呈现它。定型数组也被一同移植而来，其可为JavaScript提供快速的按位运算。</p>
</blockquote>
<h4 id="数值数据类型"><a href="#数值数据类型" class="headerlink" title="数值数据类型"></a>数值数据类型</h4><blockquote>
<p>JavaScript数字按照IEEE 754标准定义的格式存储，也就是用64个比特来存储一个浮点形式的数字。这个格式用于表示JavaScript中的整数及浮点数，两种格式间经常伴随着数字改变发生相互转换。定型数组支持存储和操作以下8种不同的数值类型：</p>
<ul>
<li><p>有符号的8位整数（int8）</p>
</li>
<li><p> 无符号的8位整数（uint8）</p>
</li>
<li><p> 有符号的16位整数（int16）</p>
</li>
<li><p> 无符号的16位整数（uint16）</p>
</li>
<li><p> 有符号的32位整数（int32）</p>
</li>
<li><p> 无符号的32位整数（uint32）</p>
</li>
<li><p> 32位浮点数（float32）</p>
</li>
<li><p>64位浮点数（float64）</p>
<blockquote>
<p>如果用普通的JavaScript数字来存储8位整数，会浪费整整56个比特，这些比特原本可以存储其他8位整数或小于56比特的数字。这也正是定型数组的一个实际用例，即更有效地利用比</p>
</blockquote>
<blockquote>
<p>所有与定型数组有关的操作和对象都集中在这8个数据类型上，但是在使用它们之前，需要创建一个数组缓冲区存储这些数据</p>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="数组缓冲区"><a href="#数组缓冲区" class="headerlink" title="数组缓冲区"></a>数组缓冲区</h4><blockquote>
<p>数组缓冲区是所有定型数组的根基，它是一段可以包含特定数量字节的内存地址。创建数组缓冲区的过程类似于在C语言中调用malloc()来分配内存，只是不需指明内存块所包含的数据类型。可以通过ArrayBuffer构造函数来创建数组缓冲区，就像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>) <span class="comment">//分配10个字节</span></span><br><span class="line"><span class="keyword">let</span> buffer2 - buffer.slice(<span class="number">4</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">console</span>.log(buffer.byteLength) <span class="comment">//10 查看字节</span></span><br><span class="line"><span class="built_in">console</span>.log(buffer2.byteLength) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>



<h4 id="通过视图操作数组缓冲区"><a href="#通过视图操作数组缓冲区" class="headerlink" title="通过视图操作数组缓冲区"></a>通过视图操作数组缓冲区</h4><blockquote>
<p>内存的接口。视图可以操作数组缓冲区或缓冲区字节的子集，并按照其中一种数值型数据类型来读取和写入数据。DataView类型是一种通用的数组缓冲区视图，其支持所有8种数值型数据类型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line">		view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer)</span><br><span class="line">		view = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>)<span class="comment">//包含位于索引5和6的字节</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的view只能操作位于索引5和索引6的字节。通过这种方法，可以基于同一个数组缓冲区创建多个view，因而可以为应用申请一整块独立的内存地址，而不是当需要空间时再动态分配。</p>
</blockquote>
<blockquote>
<p>可以通过以下几种只读属性来获取视图的信息：</p>
<ul>
<li><p> buffer　视图绑定的数组缓冲区。</p>
</li>
<li><p>byteOffset　DataView构造函数的第二个参数，默认是0，只有传入参数时才有值。此视图的从其 ArrayBuffer 开始的偏移量（以字节为单位）在构造时已固定。</p>
</li>
<li><p>· byteLength　DataView构造函数的第三个参数，默认是缓冲区的长度byteLength。</p>
<blockquote>
<p>数组缓冲区、可选的比特偏移量、可选的长度值。</p>
</blockquote>
</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br><span class="line">		view1 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer) <span class="comment">//覆盖所有字节</span></span><br><span class="line">		view2 = <span class="keyword">new</span> <span class="built_in">DataView</span>(buffer, <span class="number">5</span>, <span class="number">2</span>)<span class="comment">//数组缓冲区、可选的比特偏移量、可选的长度值。</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.buffer === buffer) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.buffer === buffer) <span class="comment">//true,</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteOffset) <span class="comment">//0,ArrayBuffer中的偏移量</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.byteOffset) <span class="comment">//5</span></span><br><span class="line"><span class="built_in">console</span>.log(view1.byteLength) <span class="comment">//10</span></span><br><span class="line"><span class="built_in">console</span>.log(view2.byteLength) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>



<h4 id="读取和写入数据"><a href="#读取和写入数据" class="headerlink" title="读取和写入数据"></a>读取和写入数据</h4><blockquote>
<p>JavaScript有8种数值型数据类型，对于其中的每一种，都能在DataView的原型上找到相应的在数组缓冲区中写入数据和读取数据的方法。这些方法名都以set或get打头，紧跟着的是每一种数据类型的缩写。例如，以下这个列表是用于读取和写入int8和unit8类型数据的方法：</p>
<ul>
<li>getInt8(byteOffset, littleEndian)　读取位于byteOffset后的int8类型数据。</li>
<li> setInt8(byteOffset, value, littleEndian)　在byteOffset处写入int8类型数据。</li>
<li> getUint8(byteOffset, littleEndian)　读取位于byteOffset后的uint8类型数据。</li>
<li> setUint8(byteOffset, value, littleEndian)　在byteOffset处写入uint8类型数据。</li>
</ul>
</blockquote>
<blockquote>
<p>get方法接受两个参数：读取数据时偏移的字节数量；和一个可选的布尔值，表示是否按照小端序进行读取（小端序是指最低有效字节位于字节0的字节顺序）。set方法接受三个参数：写入数据时偏移的比特数量；写入的值；和一个可选的布尔值，表示是否按照小端序格式存储。</p>
</blockquote>
<blockquote>
<p>尽管这里只展示了用于8位值的方法，但是有一些相同的方法也可用于操作16或32位的值，只需将每一个方法名中的8替换为16或32即可。除所有整数方法外，DataView同样支持以下读取和写入浮点数的方法：</p>
<ul>
<li>getFloat32(byteOffset, littleEndian)　读取位于byteOffset后的float32类型数据。</li>
<li> setFloat32(byteOffset, value, littleEndian)　在byteOffset处写入float32类型数据。</li>
<li> getFloat64(byteOffset, littleEndian)　读取位于byteOffset后的float64类型数据。</li>
<li> setFloat64(byteOffset, value, littleEndian)　在byteOffset处写入float64类型数据。</li>
</ul>
</blockquote>
<blockquote>
<p>写入两个int8类型的值，然后使用int16类型的方法也可以从缓冲区中读出这些值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let buffer &#x3D; new ArrayBuffer(2)</span><br><span class="line">		view &#x3D; new DataView(buffer)</span><br><span class="line">view.setInt8(0,5)</span><br><span class="line">view.setInt8(1, -1)</span><br><span class="line"></span><br><span class="line">console.log(view.getInt16(0)) &#x2F;&#x2F;1535</span><br><span class="line">console.log(view.getInt8(0)) &#x2F;&#x2F;5</span><br><span class="line">console.log(view.getInt8(1)) &#x2F;&#x2F;-1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当混合使用不同数据类型时，DataView对象是一个完美的选择，然而，如果你只使用某个特定的数据类型，那么特定类型的视图则是更好的选择。</p>
</blockquote>
<h4 id="定型数组是视图"><a href="#定型数组是视图" class="headerlink" title="定型数组是视图"></a>定型数组是视图</h4><h4 id="创建特定类型的视图"><a href="#创建特定类型的视图" class="headerlink" title="创建特定类型的视图"></a>创建特定类型的视图</h4><blockquote>
<p>定型数组构造函数可以接受多种类型的参数，所以你可以通过多种方法来创建定型数组。首先，你可以传入DataView构造函数可接受的参数来创建新的定型数组，</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>



<blockquote>
<p>定型数组构造函数可以接受多种类型的参数，所以你可以通过多种方法来创建定型数组。首先，你可以传入DataView构造函数可接受的参数来创建新的定型数组，</p>
<p>ints数组创建时含有两个空元素，每个16比特整型值需要两个字节，因而分配了4字节给该数组；floats数组创建时含有5个空元素，每个元素占4字节，所以共需要20字节。在这两种情况下，如果要访问新创建的缓冲区，则可以通过buffer属性来实现。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">2</span>) <span class="comment">//不传则不会分配比特</span></span><br><span class="line">		floats = <span class="keyword">new</span> <span class="built_in">Float32Array</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ints.byteLength) <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(ints.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(floats.byteLength) <span class="comment">//20</span></span><br><span class="line"><span class="built_in">console</span>.log(floats.length) <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用定型数组的构造函数时如果不传参数，会按照传入0来处理，这样由于缓冲区没有分配到任何比特，因而创建的定型数组不能用来保存数据。</p>
</blockquote>
<blockquote>
<p>用定型数组的构造函数时如果不传参数，会按照传入0来处理，这样由于缓冲区没有分配到任何比特，因而创建的定型数组不能用来保存数据。</p>
</blockquote>
<blockquote>
<p>第三种创建定型数组的方法是调用构造函数时，将以下任一对象作为唯一的参数传入</p>
<blockquote>
<p> 一个定型数组　该数组中的每个元素会作为新的元素被复制到新的定型数组中。举个例子，如果将一个int8数组传入到Int16Array构造函数中，int8的值会被复制到一个新的int16数组中，新的定型数组使用新的数组缓冲区。</p>
<p> 一个可迭代对象　对象的迭代器会被调用，通过检索所有条目来选取插入到定型数组的元素，如果所有元素都是不适用于该视图类型的无效类型，构造函数将会抛出一个错误。</p>
<p> 一个数组　数组中的元素会被复制到一个新的定型数组中，如果所有元素都是不适用于该视图类型的无效类型，构造函数将会抛出一个错误。</p>
<p>一个类数组对象　与传入数组的行为一致。在每个示例中，新创建的定型数组的数据均取自源对象，这在用一些值初始化定型数组时尤为有用，就像这样：</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints1 = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>,<span class="number">50</span>]) <span class="comment">//一个字节2比特</span></span><br><span class="line">		ints2 = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(ints1) <span class="comment">//一个字节4比特</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1.buffer === ints2.buffer) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ints1.byteLength) <span class="comment">//4</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1[<span class="number">0</span>])<span class="comment">//25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints1[<span class="number">1</span>]) <span class="comment">//50</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(ints2.byteLength) <span class="comment">//8</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2.length) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2[<span class="number">0</span>]) <span class="comment">//25</span></span><br><span class="line"><span class="built_in">console</span>.log(ints2[<span class="number">1</span>])  <span class="comment">//50</span></span><br></pre></td></tr></table></figure>



<h4 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h4><blockquote>
<p>每种定型数组由多个元素组成，元素大小指的是每个元素表示的字节数。该值存储在每个构造函数和每个实例的BYTES_PER_ELEMENT属性中，因此可以像这样轻松地查询元素大小：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(UInt8Array.BYTES_PER_ELEMENT) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(UInt16Array.BYTES_PER_ELEMENT) <span class="comment">//2</span></span><br><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int8Array</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ints.BYTES_PER_ELEMENT) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>



<h4 id="定型数组与普通数组的相似之处"><a href="#定型数组与普通数组的相似之处" class="headerlink" title="定型数组与普通数组的相似之处"></a>定型数组与普通数组的相似之处</h4><blockquote>
<p>可以修改length属性来改变普通数组的大小，而定型数组的length属性是一个不可写属性，所以不能修改定型数组的大小，如果尝试修改这个值，在非严格模式下会直接忽略该操作，在严格模式下会抛出错误。</p>
</blockquote>
<h4 id="通用方法"><a href="#通用方法" class="headerlink" title="通用方法"></a>通用方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copyWithin() findIndex() 	lastIndexOf() 	slice()</span><br><span class="line">entries()		 forEach()		map()						some()</span><br><span class="line">fill()			 indexOf()		reduce()				sort()</span><br><span class="line">filter()		 join()				reduceReight()	values()</span><br><span class="line">find()			 keys()				reverse()</span><br></pre></td></tr></table></figure>



<h4 id="相同的迭代器"><a href="#相同的迭代器" class="headerlink" title="相同的迭代器"></a>相同的迭代器</h4><blockquote>
<p>定型数组与普通数组有3个相同的迭代器，分别是entries()方法、keys()方法和values()方法，这意味着可以把定型数组当作普通数组一样来使用展开运算符、for-of循环。</p>
</blockquote>
<h4 id="of-方法和from-方法"><a href="#of-方法和from-方法" class="headerlink" title="of()方法和from()方法"></a>of()方法和from()方法</h4><blockquote>
<p>此外，所有定型数组都含有静态of()方法和from()方法，运行效果分别与Array.of()方法和Array.from()方法相似，区别是定型数组的方法返回定型数组，而普通数组的方法返回普通数组</p>
</blockquote>
<h4 id="定型数组与普通数组的差别"><a href="#定型数组与普通数组的差别" class="headerlink" title="定型数组与普通数组的差别"></a>定型数组与普通数组的差别</h4><blockquote>
<p>定型数组与普通数组最重要的差别是：定型数组不是普通数组。它不继承自Array，通过Array.isArray()方法检查定型数组返回的是false。</p>
</blockquote>
<h4 id="行为差异"><a href="#行为差异" class="headerlink" title="行为差异"></a>行为差异</h4><blockquote>
<p>当操作普通数组时，其可以变大变小，但定型数组却始终保持相同的尺寸。给定型数组中不存在的数值索引赋值会被忽略，而在普通数组中就可以</p>
</blockquote>
<blockquote>
<p>定型数组同样会检查数据类型的合法性，0被用于代替所有非法值。例如：</p>
<p>所有修改定型数组值的方法执行时都会受到相同限制，例如，如果给map()方法传入的函数返回非法值，</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let ints &#x3D; new Int16Array([&#39;h1&#39;])</span><br><span class="line">console.log(ints.length) &#x2F;&#x2F;1</span><br><span class="line">console.log(ints[0]) &#x2F;&#x2F;0,0被用来替换非法值</span><br></pre></td></tr></table></figure>

<h4 id="缺失的方法"><a href="#缺失的方法" class="headerlink" title="缺失的方法"></a>缺失的方法</h4><blockquote>
<p>尽管定型数组包含许多与普通数组相同的方法，但也缺失了几个。以下方法在定型数组中不可使用</p>
<p>除concat()方法外，这个列表中的方法都可以改变数组的尺寸，由于定型数组的尺寸不可更改，因而这些方法不适用于定型数组。定型数组不支持concat()方法是因为两个定型数组合并后的结果（尤其当两个数组分别处理不同数据类型时）会变得不确定，这直接违背了使用定型数组的初衷。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">concat() shift()</span><br><span class="line">pop()		 splice()	</span><br><span class="line">push()	 unshift()</span><br></pre></td></tr></table></figure>



<h4 id="附加方法"><a href="#附加方法" class="headerlink" title="附加方法"></a>附加方法</h4><blockquote>
<p>最后，定型数组中还有两个没出现在普通数组中的方法：set()和subarray()。这两个方法的功能相反，set()方法将其他数组复制到已有的定型数组，subarray()提取已有定型数组的一部分作为一个新的定型数组。</p>
<blockquote>
<p>set()方法接受两个参数：一个是数组（定型数组或普通数组都支持）；一个是可选的偏移量，表示开始插入数据的位置，如果什么都不传，默认的偏移量为0。合法数据从作为参数传入的数组复制至目标定型数组中，例如：</p>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>(<span class="number">4</span>)</span><br><span class="line">ints.set([<span class="number">25</span>,<span class="number">40</span>])</span><br><span class="line">ints.set([<span class="number">75</span>,<span class="number">100</span>],<span class="number">2</span>) <span class="comment">//2-开始插入数据的位置，不传为0</span></span><br><span class="line"><span class="built_in">console</span>.log(ints.toString()) <span class="comment">//25,40,75,100,2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>subarray()方法接受两个参数：一个是可选的开始位置，一个是可选的结束位置（与slice()方法的结束位置一样，不包含当前位置的数据），最后返回一个新的定型数组。也可以省略这两个参数来克隆一个新的定型数组。例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ints = <span class="keyword">new</span> <span class="built_in">Int16Array</span>([<span class="number">25</span>,<span class="number">50</span>,<span class="number">75</span>,<span class="number">100</span>])</span><br><span class="line">	subints1= ints.subarray()</span><br><span class="line">	subints2= ints.subarray(<span class="number">2</span>)</span><br><span class="line">	subints3= ints.subarray(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(subints1.toString()) <span class="comment">//25,50,75,100</span></span><br><span class="line"><span class="built_in">console</span>.log(subints2.toString()) <span class="comment">//75,100</span></span><br><span class="line"><span class="built_in">console</span>.log(subints3.toString()) <span class="comment">//50,75</span></span><br></pre></td></tr></table></figure>



<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>ECMAScript 6延续了ECMAScript 5的传统，进一步强化了数组功能。新增的特性包括两种创建数组的新方法：Array.of()和Array.from()。Array.from()方法也可以将可迭代对象和类数组对象转换为数组。这两个方法都通过派生数组类继承，并通过Symbol.species属性来决定返回值的数据类型（其他继承方法在返回数组时同样也用到了Symbol.species）</p>
</blockquote>
<blockquote>
<p>此外，还介绍了几种新的数组方法。fill()方法和copyWithin()方法可以更改数组中特定位置的元素值；find()方法和findIndex()方法可以用于在数组中查找匹配某些标准的第一个元素，find()方法返回匹配规则的第一个元素，findIndex()方法返回该元素的索引值。</p>
</blockquote>
<blockquote>
<p>严格来讲定型数组不是数组，因为它们不继承自Array，但它们确实看起来很像数组，行为也很像数组。定型数组中的值属于8种不同数值数据类型中的一个，它们是基于ArrayBuffer对象构建的，用于表示一个或多个数字底层的数位。按位运算更适合用定型数组来操作，因为其不会像JavaScript数字类型的操作那样将值在多种格式间反复转换。</p>
</blockquote>
<h4 id="11-promise与异步编程"><a href="#11-promise与异步编程" class="headerlink" title="11.promise与异步编程"></a>11.promise与异步编程</h4><blockquote>
<p>JavaScript引擎同一时刻只能执行一个代码块，所以需要跟踪即将运行的代码，那些代码被放在一个任务队列（job queue）中，每当一段代码准备执行时，都会被添加到任务队列。每当JavaScript引擎中的一段代码结束执行，事件循环（eventloop）会执行队列中的下一个任务，它是JavaScript引擎中的一段程序，负责监控代码执行并管理任务队列。请记住，队列中的任务会从第一个一直执行到最后一个。</p>
</blockquote>
<h4 id="Promise的生命周期"><a href="#Promise的生命周期" class="headerlink" title="Promise的生命周期"></a>Promise的生命周期</h4><blockquote>
<p>每个Promise都会经历一个短暂的生命周期：先是处于进行中（pending）的状态，此时操作尚未完成，所以它也是未处理（unsettled）的；一旦异步操作执行结束，Promise则变为已处理（settled）的状态</p>
</blockquote>
<blockquote>
<p>内部属性[[PromiseState]]被用来表示Promise的3种状态：”pending”、”fulfilled”及”rejected”。这个属性不暴露在Promise对象上，所以不能以编程的方式检测Promise的状态，只有当Promise的状态改变时，通过then()方法来采取特定的行动。</p>
</blockquote>
<blockquote>
<p>所有Promise都有then()方法，它接受两个参数：第一个是当Promise的状态变为fulfilled时要调用的函数，与异步操作相关的附加数据都会传递给这个完成函数（fulfillment function）；第二个是当Promise的状态变为rejected时要调用的函数，其与完成时调用的函数类似，所有与失败状态相关的附加数据都会传递给这个拒绝函数（rejectionfunction）。</p>
<blockquote>
<p>如果一个对象实现了上述的then()方法，那这个对象我们称之为thenable对象。所有的Promise都是thenable对象，但并非所有thenable对象都是Promise。</p>
</blockquote>
</blockquote>
<blockquote>
<p>如果向Promise.resolve()方法或Promise.reject()方法传入一个Promise，那么这个Promise会被直接返回。</p>
</blockquote>
<h4 id="非Promise的Thenable对象"><a href="#非Promise的Thenable对象" class="headerlink" title="非Promise的Thenable对象"></a>非Promise的Thenable对象</h4><blockquote>
<p>Promise.resolve()方法和Promise.reject()方法都可以接受非Promise的Thenable对象作为参数。如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise，并在then()函数中被调用.</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thenable = &#123;</span><br><span class="line">	then: <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>) </span>&#123;</span><br><span class="line">		resolve(<span class="number">42</span>)</span><br><span class="line">		reject(<span class="number">21</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1 =<span class="built_in">Promise</span>.resolve(thenable)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value) <span class="comment">//42</span></span><br><span class="line">&#125;)</span><br><span class="line">p1.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value) <span class="comment">//21</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="执行器错误"><a href="#执行器错误" class="headerlink" title="执行器错误"></a>执行器错误</h4><blockquote>
<p>如果执行器内部抛出一个错误，则Promise的拒绝处理程序就会被调用，例如：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="function"><span class="title">Promise</span>(<span class="params">resolve, reject</span>)</span> &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> Erroe(<span class="string">&#x27;explosion&#x27;</span>)</span><br><span class="line">  <span class="comment">//等价于</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;explosion&#x27;</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span>(ex) &#123;</span><br><span class="line">    reject(ex)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(error.message) <span class="comment">//explosion</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="全局的Promise拒绝处理"><a href="#全局的Promise拒绝处理" class="headerlink" title="全局的Promise拒绝处理"></a>全局的Promise拒绝处理</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected = <span class="built_in">Promise</span>.reject(<span class="number">42</span>)</span><br><span class="line"><span class="comment">//此时，rejected还没有被处理</span></span><br><span class="line">rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//现在，rejected已经被处理</span></span><br><span class="line">	<span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="Node-js环境的拒绝处理"><a href="#Node-js环境的拒绝处理" class="headerlink" title="Node.js环境的拒绝处理"></a>Node.js环境的拒绝处理</h4><blockquote>
<p>在Node.js中，处理Promise拒绝时会触发process对象上的两个事件</p>
<blockquote>
<ul>
<li><p>unhandledRejection　在一个事件循环中，当Promise被拒绝，并且没有提供拒绝处理程序时被调用。</p>
</li>
<li><p> rejectionHandled　在一个事件循环后，当Promise被拒绝，并且没有提供拒绝处理程序时被调用。</p>
</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line">process.on(<span class="string">&#x27;unhandleRejection&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(reason.message) <span class="comment">//&#x27;explosion&#x27;</span></span><br><span class="line">	<span class="built_in">console</span>.log(rejected === promise) <span class="comment">//true</span></span><br><span class="line">&#125;)</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> Erroe(<span class="string">&#x27;explosion&#x27;</span>))</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">process.on(<span class="string">&#x27;unhandleRejection　&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>)</span>&#123;</span><br><span class="line">	possiblyUnhandledRejections.set(promise, reason)</span><br><span class="line">&#125;)</span><br><span class="line">process.on(<span class="string">&#x27;rejectionHandled　&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>)</span>&#123;</span><br><span class="line">	possiblyUnhandledRejections.delete(promise)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(reason.message ? reason.message : reason)</span><br><span class="line">	&#125;)</span><br><span class="line">	handleRejection(promise, reason)</span><br><span class="line">	possiblyUnhandledRejections.clear()</span><br><span class="line">&#125;,<span class="number">60000</span>)</span><br></pre></td></tr></table></figure>



<h4 id="浏览器环境的拒绝处理"><a href="#浏览器环境的拒绝处理" class="headerlink" title="浏览器环境的拒绝处理"></a>浏览器环境的拒绝处理</h4><blockquote>
<p>浏览器也是通过触发两个事件来识别未处理的拒绝的，虽然这些事件是在window对象上触发的，但实际上与Node.js中的完全等</p>
<blockquote>
<ul>
<li><p>unhandledrejection　在一个事件循环中，当Promise被拒绝，并且没有提供拒绝处理程序时被调用。</p>
</li>
<li><p>rejectionhandled　在一个事件循环后，当Promise被拒绝，并且没有提供拒绝处理程序时被调用。</p>
<blockquote>
<p>在Node.js实现中，事件处理程序接受多个独立参数；而在浏览器中，事件处理程序接受一个有以下属性的事件对象作为参数：</p>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rejected</span><br><span class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(event.type) <span class="comment">//&#x27;unhandledrejection&#x27;</span></span><br><span class="line">	<span class="built_in">console</span>.log(event.reason.message) <span class="comment">//&#x27;explosion&#x27;</span></span><br><span class="line">	<span class="built_in">console</span>.log(rejected === event.message) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(event.type) <span class="comment">//&#x27;rejectionhandled&#x27;</span></span><br><span class="line">	<span class="built_in">console</span>.log(event.reason.message) <span class="comment">//&#x27;explosion&#x27;</span></span><br><span class="line">	<span class="built_in">console</span>.log(rejected === event.message) <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;explosion&#x27;</span>))</span><br></pre></td></tr></table></figure>



<h4 id="在Promise链中返回Promise"><a href="#在Promise链中返回Promise" class="headerlink" title="在Promise链中返回Promise"></a>在Promise链中返回Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">	resolve(<span class="number">43</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//42</span></span><br><span class="line">  <span class="keyword">return</span> p2</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value) <span class="comment">//43</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h4 id="Promise-all-方法"><a href="#Promise-all-方法" class="headerlink" title="Promise.all()方法"></a>Promise.all()方法</h4><blockquote>
<p>Promise.all()方法只接受一个参数并返回一个Promise，该参数是一个含有多个受监视Promise的可迭代对象（例如，一个数组），只有当可迭代对象中所有Promise都被解决后返回的Promise才会被解决，只有当可迭代对象中所有Promise都被完成后返回的Promise才会被完成，正如这个示例所示：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">	resolve(42)</span><br><span class="line">&#125;)</span><br><span class="line">let p2 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">	resolve(43)</span><br><span class="line">&#125;)</span><br><span class="line">let p3 &#x3D; new Promise(function(resolve, reject) &#123;</span><br><span class="line">	resolve(44)</span><br><span class="line">&#125;)</span><br><span class="line">let p4 &#x3D; Promise.all([p1,p2,p3])</span><br><span class="line">p4.then(function(value) &#123;</span><br><span class="line">	console.log(Array.isArray(value)) &#x2F;&#x2F;true</span><br><span class="line">	console.log(value[0]) &#x2F;&#x2F;42</span><br><span class="line">	console.log(value[1]) &#x2F;&#x2F;43</span><br><span class="line">	console.log(value[2]) &#x2F;&#x2F;44</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>





<h4 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race()方法"></a>Promise.race()方法</h4><blockquote>
<p>Promise.race()方法监听多个Promise的方法稍有不同：它也接受含多个受监视Promise的可迭代对象作为唯一参数并返回一个Promise，但只要有一个Promise被解决返回的Promise就被解决，无须等到所有Promise都被完成。一旦数组中的某个Promise被完成，Promise.race()方法也会像Promise.all()方法一样返回一个特定的Promise</p>
<p>传给Promise.race()方法的Promise会进行竞选，以决出哪一个先被解决，如果先解决的是已完成Promise，则返回已完成Promise；如果先解决的是已拒绝Promise，则返回已拒绝Promise。</p>
</blockquote>
<h4 id="代理（proxy）和反射（reflection）"><a href="#代理（proxy）和反射（reflection）" class="headerlink" title="代理（proxy）和反射（reflection）"></a>代理（proxy）和反射（reflection）</h4><blockquote>
<p>调用new Proxy()可创建代替其他目标（target）对象的代理，它虚拟化了目标，所以二者看起来功能一致。代理可以拦截JavaScript引擎内部目标的底层对象操作，这些底层操作被拦截后会触发响应特定操作的陷阱函数。</p>
<p>反射API以Reflect对象的形式出现，对象中方法的默认特性与相同的底层操作一致，而代理可以覆写这些操作，每个代理陷阱对应一个命名和参数都相同的Reflect方法。表12-1总结了代理陷阱的特性。</p>
</blockquote>
<h4 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h4><blockquote>
<p>用Proxy构造函数创建代理需要传入两个参数：目标（target）和处理程序（handler）。处理程序是定义一个或多个陷阱的对象，在代理中，除了专门为操作定义的陷阱外，其余操作均使用默认特性。不使用任何陷阱的处理程序等价于简单的转发代理，就像这样：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;) <span class="comment">//未定义陷阱</span></span><br><span class="line">proxy.name = <span class="string">&#x27;proxy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// &#x27;proxy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// &#x27;proxy&#x27;</span></span><br><span class="line">target.name = <span class="string">&#x27;target&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// &#x27;target&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">// &#x27;target&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>将”proxy”赋值给proxy.name属性时会在目标上创建name，代理只是简单地将操作转发给目标，它不会储存这个属性。由于proxy.name和target.name引用的都是target.name，因此二者的值相同，从而为target.name设置新值后，proxy.name也一同变化。</p>
</blockquote>
<h4 id="使用set陷阱验证属性"><a href="#使用set陷阱验证属性" class="headerlink" title="使用set陷阱验证属性"></a>使用set陷阱验证属性</h4><blockquote>
<p>假设你想创建一个属性值是数字的对象，对象中每新增一个属性都要加以验证，如果不是数字必须抛出错误。为了实现这个任务，可以定义一个set陷阱来覆写设置值的默认特性。set陷阱接受4个参数：</p>
<ul>
<li>trapTarget　用于接收属性（代理的目标）的对象。</li>
<li> key　要写入的属性键（字符串或Symbol类型）。</li>
<li> value　被写入属性的值。</li>
<li> receiver　操作发生的对象（通常是代理）</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">	name: <span class="string">&#x27;libai&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">	<span class="function"><span class="title">set</span>(<span class="params">trapTarget, key, value, receiver</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(!trapTarget.hasOwnProperty(key)) &#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">isNaN</span>(value)) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;属性必须是数字&#x27;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key,value,receiver)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//添加一个新属性</span></span><br><span class="line">proxy.count = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.count) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(target.count) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//已有属性， 可以直接重新赋值</span></span><br><span class="line">proxy.name = <span class="string">&#x27;proxy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">//&#x27;proxy&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(target.name) <span class="comment">//&#x27;proxy&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//目标上没有anotherName属性，所以它的值需要被验证 ，而由于&quot;proxy&quot;不是一个数字值，因此抛出错误。</span></span><br><span class="line">proxy.name = <span class="string">&#x27;proxy&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="用get陷阱验证对象结构（ObjectShape）"><a href="#用get陷阱验证对象结构（ObjectShape）" class="headerlink" title="用get陷阱验证对象结构（ObjectShape）"></a>用get陷阱验证对象结构（ObjectShape）</h4><blockquote>
<p>JavaScript有一个时常令人感到困惑的特殊行为，即读取不存在的属性时不会抛出错误，而是用undefined代替被读取属性的值，就像在这个示例中：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;,&#123;</span><br><span class="line">	<span class="function"><span class="title">get</span>(<span class="params">trapTraget, key, receiver</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(!(key <span class="keyword">in</span> trapTraget)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;属性&#x27;</span> + key + <span class="string">&#x27;不存在&#x27;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTraget, key, receiver)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.nnn) <span class="comment">//属性 nnn 不存在</span></span><br></pre></td></tr></table></figure>



<h4 id="使用has陷阱隐藏已有属性"><a href="#使用has陷阱隐藏已有属性" class="headerlink" title="使用has陷阱隐藏已有属性"></a>使用has陷阱隐藏已有属性</h4><blockquote>
<p>可以用in操作符来检测给定对象中是否含有某个属性，如果自有属性或原型属性匹配这个名称或Symbol就返回true</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">	name: <span class="string">&#x27;李白&#x27;</span>,</span><br><span class="line">	value: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">	<span class="function"><span class="title">has</span>(<span class="params">trapTraget, key</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(key === <span class="string">&#x27;value&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTraget, key, receiver)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> proxy) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> proxy) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> proxy) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>





<h4 id="用deleteProperty陷阱防止删除属性"><a href="#用deleteProperty陷阱防止删除属性" class="headerlink" title="用deleteProperty陷阱防止删除属性"></a>用deleteProperty陷阱防止删除属性</h4><blockquote>
<p>Reflect.deleteProperty()方法为deleteProperty陷阱提供默认实现，并且接受同样的两个参数。结合二者可以改变delete的具体表现行为，例如，可以像这样来确保value属性不会被删除：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">	name: <span class="string">&#x27;李白&#x27;</span>,</span><br><span class="line">	value: <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,&#123;</span><br><span class="line">	<span class="function"><span class="title">deleteProperty</span>(<span class="params">trapTraget, key</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(key === <span class="string">&#x27;value&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTraget, key, receiver)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> proxy) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = <span class="keyword">delete</span> proxy.value</span><br><span class="line"><span class="built_in">console</span>.log(result1) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;value&#x27;</span> <span class="keyword">in</span> proxy) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> proxy) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="keyword">delete</span> proxy.name</span><br><span class="line"><span class="built_in">console</span>.log(result2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="原型代理陷阱"><a href="#原型代理陷阱" class="headerlink" title="原型代理陷阱"></a>原型代理陷阱</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">	<span class="function"><span class="title">getPrototypeOf</span>(<span class="params">trapTraget</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">setPrototypeOf</span>(<span class="params">trapTarget, proto</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototyoeOf(target) <span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototyoeOf(proxy) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype)<span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(proxyProto) <span class="comment">// null</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeof(target, &#123;&#125;)</span><br><span class="line"><span class="comment">//给不存在的属性赋值会报错</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeof(proxy, &#123;&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="Reflect-getPrototypeOf-方法和Object-getPrototypeOf-的区别"><a href="#Reflect-getPrototypeOf-方法和Object-getPrototypeOf-的区别" class="headerlink" title="Reflect.getPrototypeOf()方法和Object.getPrototypeOf()的区别"></a>Reflect.getPrototypeOf()方法和Object.getPrototypeOf()的区别</h4><blockquote>
<p>Reflect.getPrototypeOf()方法是内部[[GetPrototypeOf]]操作的包裹器（包含一些输入验证）</p>
<p>Object.getPrototypeOf()方法会强制让数字1变为Number对象，所以你可以检索它的原型并得到返回值Number.prototype；而由于Reflect.getPrototypeOf()方法不强制转化值的类型，而且1又不是一个对象，故会抛出一个错误。</p>
</blockquote>
<h4 id="Reflect-setPrototypeOf-方法和Object-setPrototypeOf-的区别"><a href="#Reflect-setPrototypeOf-方法和Object-setPrototypeOf-的区别" class="headerlink" title="Reflect.setPrototypeOf()方法和Object.setPrototypeOf()的区别"></a>Reflect.setPrototypeOf()方法和Object.setPrototypeOf()的区别</h4><blockquote>
<p>Reflect.setPrototypeOf()方法与[[SetPrototypeOf]]的关系与之相同。Object上相应的方法虽然也调用了[[GetPrototypeOf]]和[[SetPrototypeOf]]，但在此之前会执行一些额外步骤，并通过检查返回值来决定下一步的操作</p>
<p>Reflect.setPrototypeOf()方法与Object.setPrototypeOf()方法也不尽相同。具体而言，Reflect.setPrototypeOf()方法返回一个布尔值来表示操作是否成功，成功时返回true，失败则返回false；而Object.setPrototypeOf()方法一旦失败则会抛出一个错误。</p>
</blockquote>
<blockquote>
<p><code>**Object.preventExtensions()**</code>方法让一个对象变的不可扩展，也就是永远不能再添加新的属性。</p>
<p><code>**Object.isExtensible()**</code> 方法判断一个对象是否是可扩展的（是否可以在它上面添加新的属性）。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">	<span class="function"><span class="title">isExtensible</span>(<span class="params">trapTarget</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="title">preventExtensions</span>(<span class="params">trapTarget</span>)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(trapTarget)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target)) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(proxy)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="todo-跳过"><a href="#todo-跳过" class="headerlink" title="todo 跳过"></a>todo 跳过</h4><h4 id="什么是模块"><a href="#什么是模块" class="headerlink" title="什么是模块"></a>什么是模块</h4><blockquote>
<p><strong>模块是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。</strong>与共享一切架构相反的是，在模块顶部创建的变量不会自动被添加到全局共享作用域，这个变量仅在模块的顶级作用域中存在，而且模块必须导出一些外部代码可以访问的元素，如变量或函数。模块也可以从其他模块导入绑定。</p>
<p>首先，在模块的顶部，this的值是undefined；其次，模块不支持HTML风格的代码注释，这是从早期浏览器残余下来的JavaScript特性。</p>
</blockquote>
<h4 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h4><blockquote>
<p>脚本，也就是任何不是模块的JavaScript代码。</p>
</blockquote>
<blockquote>
<p>导入绑定的列表看起来与解构对象很相似，但它不是</p>
</blockquote>
<blockquote>
<p>为了最好地兼容多个浏览器和Node.js环境，一定要在字符串之前包含/、./或../来表示要导入的文件。</p>
</blockquote>
<h4 id="模块语法的限制"><a href="#模块语法的限制" class="headerlink" title="模块语法的限制"></a>模块语法的限制</h4><blockquote>
<p>export和import的一个重要的限制是，它们必须在其他语句和函数之外使用。</p>
<p>不能动态地导入或导出绑定。export和import关键字被设计成静态的，因而像文本编辑器这样的工具可以轻松地识别模块中哪些信息是可用的。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&#x27;李白&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">	name = newName	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">//&#x27;李白&#x27;</span></span><br><span class="line">setName(<span class="string">&#x27;杜甫&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">//&#x27;杜甫&#x27;</span></span><br><span class="line">name = <span class="string">&#x27;白居易&#x27;</span> <span class="comment">//抛出错误</span></span><br></pre></td></tr></table></figure>



<h4 id="导出和导入时重命名"><a href="#导出和导入时重命名" class="headerlink" title="导出和导入时重命名"></a>导出和导入时重命名</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> add&#125; <span class="comment">//函数sum()是本地名称，add()是导出时使用的名称。</span></span><br></pre></td></tr></table></figure>



<h4 id="模块的默认值"><a href="#模块的默认值" class="headerlink" title="模块的默认值"></a>模块的默认值</h4><blockquote>
<p>由于在诸如CommonJS（浏览器外的另一个JavaScript使用规范）的其他模块系统中，从模块中导出和导入默认值是一个常见的做法，该语法被进行了优化。<strong>模块的默认值指的是通过default关键字指定的单个变量、函数或类，</strong>只能为每个模块设置一个默认的导出值，导出时多次使用default关键字是一个语法错误</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sum</span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> <span class="keyword">default</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> sum, color&#125; form <span class="string">&#x27;./example.js&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在import语句中，默认值必须排在非默认值之前。</p>
</blockquote>
<h4 id="重新导出一个绑定"><a href="#重新导出一个绑定" class="headerlink" title="重新导出一个绑定"></a>重新导出一个绑定</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123;sum&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">export</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123;sum <span class="keyword">as</span> add&#125; <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./example.js&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="无绑定导入"><a href="#无绑定导入" class="headerlink" title="无绑定导入"></a>无绑定导入</h4><blockquote>
<p>某些模块可能不导出任何东西，相反，它们可能只修改全局作用域中的对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.pushAll = <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">Array</span>.isArray(items)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;参数必须是一个数组&#x27;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.push(...items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即使没有任何导出或导入的操作，这也是一个有效的模块。这段代码既可以用作模块也可以用作脚本。由于它不导出任何东西，因而你可以使用简化的导入操作来执行模块代码，而且不导入任何的绑定：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./example.js&#x27;</span></span><br><span class="line"><span class="keyword">let</span> colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> items = []</span><br><span class="line">items.pushAll(colors)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>无绑定导入最有可能被应用于创建Polyfill和Shim。</p>
</blockquote>
<h4 id="在Web浏览器中使用模块"><a href="#在Web浏览器中使用模块" class="headerlink" title="在Web浏览器中使用模块"></a>在Web浏览器中使用模块</h4><blockquote>
<p>即使在ECMAScript 6出现以前，Web浏览器也有多种方式可以将JavaScript包含在Web应用程序中，这些脚本加载的方法分别是：</p>
<blockquote>
<ul>
<li>在<script>元素中通过src属性指定一个加载代码的地址来加载JavaScript代码文件。</li>
<li> 将JavaScript代码内嵌到没有src属性的<script>元素中。</li>
<li> 通过Web Worker或Service Worker的方法加载并执行JavaScript代码文件。</li>
</ul>
</blockquote>
</blockquote>
<h4 id="Web浏览器中的模块加载顺序"><a href="#Web浏览器中的模块加载顺序" class="headerlink" title="Web浏览器中的模块加载顺序"></a>Web浏览器中的模块加载顺序</h4><blockquote>
<p>模块与脚本不同，它是独一无二的，可以通过import关键字来指明其所依赖的其他文件，并且这些文件必须被加载进该模块才能正确执行。为了支持该功能，<script type ="module">执行时自动应用defer属性。</p>
<p>加载脚本文件时，defer是可选属性；加载模块时，它就是必需属性。一旦HTML解析器遇到具有src属性的<script type ="module">，模块文件便开始下载，直到文档被完全解析模块才会执行。模块按照它们出现在HTML文件中的顺序执行.</p>
</blockquote>
<h4 id="Web浏览器中的异步模块加载"><a href="#Web浏览器中的异步模块加载" class="headerlink" title="Web浏览器中的异步模块加载"></a>Web浏览器中的异步模块加载</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无法保证两个哪个先执行</span></span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> <span class="keyword">async</span> src=<span class="string">&quot;module1.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">&quot;module&quot;</span> <span class="keyword">async</span> src=<span class="string">&quot;module2.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>两个模块文件被异步加载。只是简单地看这个代码判断不出哪个模块先执行，如果module1.js首先完成下载（包括其所有的导入资源），它将先执行；如果module2.js首先完成下载，那么它将先执行。</p>
</blockquote>
<h4 id="将模块作为Woker加载"><a href="#将模块作为Woker加载" class="headerlink" title="将模块作为Woker加载"></a>将模块作为Woker加载</h4><blockquote>
<p>Worker，例如Web Worker和Service Woker，可以在网页上下文之外执行JavaScript代码。创建新Worker的步骤包括：创建一个新的Worker实例（或其他的类），传入JavaScript文件的地址。默认的加载机制是按照脚本的方式加载文件，如下所示：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照脚本的方式加载script.js</span></span><br><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">&quot;script.js&quot;</span>)</span><br><span class="line"><span class="comment">//按照模块的方式加载script.js</span></span><br><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">&quot;script.js&quot;</span>, &#123;<span class="attr">type</span>: <span class="string">&#x27;module&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="浏览器模块说明符解析"><a href="#浏览器模块说明符解析" class="headerlink" title="浏览器模块说明符解析"></a>浏览器模块说明符解析</h4><blockquote>
<p>浏览器要求模块说明符具有以下几种格式之一：</p>
<blockquote>
<p>· 以/开头的解析为从根目录开始。</p>
<p>· 以./开头的解析为从当前目录开始。</p>
<p>· 以../开头的解析为从父目录开始。</p>
<p>· URL格式。</p>
</blockquote>
</blockquote>
<h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><blockquote>
<p>ECMAScript 6语言中的模块是一种打包和封装功能的方式，模块的行为与脚本不同，模块不会将它的顶级变量、函数和类修改为全局作用域，而且this的值为undefined。要实现这个行为，需通过不同的模式来加载模块。</p>
<p>必须导出所有要让模块使用者使用的功能，变量、函数和类都可以导出，每个模块还可以有一个默认的导出值。导出后，另一个模块可以导入部分或所有导出的名称，这些名称表现得像是通过let定义的，运行起来与块级作用域绑定一样，在同一个模块中无法重新声明它们。</p>
<p>如果模块只操作全局作用域，则不需要导出任何值。实际上，导入这样一个模块不会将任何绑定引入到当前的模块作用域。由于模块必须运行在不同的模式下，因此浏览器引入&lt;scripttype=”module”&gt;来表示模块中应该执行的源文件或内联代码。通过<script type="module">加载的模块文件默认具有defer属性。在文档完全被解析之后，模块也按照它们在包含文档中出现的顺序依次执行。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/07/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/" data-id="cktu4gyl5000qqayce2khhmhs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/11/29/JS%E9%9D%A2%E8%AF%95%E9%A2%98/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JS面试题
        
      </div>
    </a>
  
  
    <a href="/2020/03/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">你不知道的javascript(凯尔辛普森)</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/https-www-tslang-cn-docs-handbook-type-inference-html/" rel="tag">https://www.tslang.cn/docs/handbook/type-inference.html</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/https-www-tslang-cn-docs-handbook-type-inference-html/" style="font-size: 10px;">https://www.tslang.cn/docs/handbook/type-inference.html</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/22/vue3/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/03/HTML5%E6%96%B0%E7%89%B9%E6%80%A7/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/08/03/webscoket/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/07/29/axios/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/03/01/Vue-Router/">vue-router</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>